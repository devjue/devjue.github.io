{"categories":[{"title":"web","uri":"https://devjue.github.io/categories/web/"},{"title":"区块链","uri":"https://devjue.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"posts":[{"content":" 使用 GitHub 创建一个仓库，用于对 Hugo 博客的版本进行管理。有了 GitHub 仓库后，还可以在多终端（个人电脑、工作电脑等）上同时撰写博客。\n初始化本地仓库 $ cd /path/to/site/ $ git init $ git remote add origin git@github.com:yourname/yourblog.git  进入 Hugo 站点目录 /path/to/site/，初始化 git，并将 git@github.com:yourname/yourblog.git（这个仓库已经提前创建，且没有提交记录）设置为你的远程仓库。\n选择需要提交的文件 跟踪空目录 刚初始化的 Hugo 博客目录如下所示：\narchetypes/ default.md content/ data/ layouts/ static/ themes/  可见，除了 archetypes/，其它都是空目录。\n由于 git 只跟踪文件的变动，不跟踪目录。所以，即便使用 git add，没有文件的空目录也不会被提交到暂存区。针对这一点，如果想提交站点的完整结构，需要在空目录下添加文件，这个文件可以没有任何内容。有一个惯例做法是向想要提交的空目录中添加名为 .gitkeep 的空文件，此文件的作用只是让其所在的目录被提交。\n$ touch content/.gitkeep data/.gitkeep layouts/.gitkeep static/.gitkeep themes/.gitkeep  忽略 public/ 目录 由于 public/ 目录下的文件完全是由 Hugo 生成的，我们可以随时生成最新的内容，所以建议不提交该目录。\n$ echo \u0026quot;public/\u0026quot; \u0026gt;\u0026gt; .gitignore  在 .gitignore 中加入 public/，目录 public/ 及其路径下的所有文件将不会被提交。\n添加子模块 Hugo 中有很多主题可选，这为写博客带来了很大的便利及乐趣。这些主题大多是 GitHub 上的项目，如果我们想跟踪主题的更新，及时获取其最新版本，推荐将该主题的项目作为子模块添加到我们的博客项目中。还是以我选择的 主题 pure 为例：\n$ git submodule add git@github.com:xiaoheiAh/hugo-theme-pure.git themes/pure  提交到远程仓库 GitHub 最后，提交目录下的所有文件。\n$ git add -A $ git commit -m \u0026quot;init blog\u0026quot; $ git push -u origin master  克隆子模块 当我们使用 git clone git@github.com:yourname/yourblog.git 克隆项目时，子模块是不会被克隆的。下面介绍两个方法来克隆子模块。\n使用 git submodule 先克隆项目，再根据需要克隆子模块。\n$ git clone git@github.com:yourname/yourblog.git $ cd yourblog $ git submodule init $ git submodule update  使用 --recurse-submodules 在克隆项目时，就克隆其子模块。\n$ git clone git@github.com:yourname/yourblog.git --recurse-submodules   注意，当在新环境中使用 Hugo 生成静态站点时，需要先克隆作为子模块的 Hugo 主题。\n ","id":0,"section":"posts","summary":"使用 GitHub 创建一个仓库，用于对 Hugo 博客的版本进行管理。有了 GitHub 仓库后，还可以在多终端（个人电脑、工作电脑等）上同时撰写博客。 初始化本地仓库 $ cd /path/to/site/ $ git","tags":["git"],"title":"Hugo 博客搭建之三：使用 GitHub 对博客版本进行管理","uri":"https://devjue.github.io/2019/12/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E4%B8%89%E4%BD%BF%E7%94%A8github%E5%AF%B9%E5%8D%9A%E5%AE%A2%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86/","year":"2019"},{"content":" 网络完全形成 让我们使用一致的视觉词汇来回顾一下我们的网络。我们已经使用更紧凑的视觉语法对其进行稍微的重组，因为它可以更好地适应更大的拓扑：\n在这张图中，我们看到 Fabric 区块链网络由两个应用程序通道和一个排序服务通道组成。组织 R1 和 R4 负责排序服务通道，R1 和 R2 负责蓝色应用程序通道，而 R2 和 R3 负责红色应用程序通道。客户端应用程序 A1 时组织 R1 多元素，CA1 是它的证书颁发机构。注意，组织 R2 的 peer P2 可以使用蓝色和红色应用程序通道的通信设施。每一个应用程序通道都有自己的通道配置，在这个例子中是 CC1 和 CC2。系统通道的通道配置是网络配置 NC4 的一部分。\n我们现在构建示例 Hyperledger Fabric 区块链网络概念之旅的最后。我们已经创建了一个具有四个组织、两个通道、三个 peer 节点、两个智能合约和一个排序服务的网络。它由四个证书颁发机构支持。它为三个客户端应用程序提供账本和智能合约服务，我们可以通过两个通道与其进行交互。花一点时间浏览一下图中网络的细节，并随意回看此主题以增强您的知识，或者转到更详细的主题。\n网络组件摘要 这是我们讨论过的网络组件的概要：\n Ledger. 每个通道都有一个。包括 Blockchain 和 World state 。 Smart contract (aka chaincode) Peer nodes Ordering service Channel Certificate Authority  网络总结 在本主题中，我们已经看到不同组件如何共享其基础设施，以提供一个完整的 Hyperledger Fabric 区块链网络。我们已经看到共有的基础设施如何组成通道，以提供独立管理的私密通信机制。我们已经看到像客户端应用程序、管理员、peer 和排序者这些参与者，如何使用来自它们各自证书颁发机构的证书来识别其来自不同的组织。反过来，我们已经看到，定义协商一致权限的策略的重要性，这些权限是在网络和通道资源上组织的参与者所拥有的。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#network-fully-formed\n","id":1,"section":"posts","summary":"网络完全形成 让我们使用一致的视觉词汇来回顾一下我们的网络。我们已经使用更紧凑的视觉语法对其进行稍微的重组，因为它可以更好地适应更大的拓扑： 在","tags":["Hyperledger","Fabric"],"title":"Hyperledger Fabric 1.4 官方文档翻译之七：Key Concepts - Blockchain network (7)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%B8%83key-concepts-blockchain-network-7/","year":"2019"},{"content":" https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#joining-a-peer-to-multiple-channels\n把 peer 加入多个通道 在网络开发的最后阶段，让我们将重点转回到组织 R2。我们可以利用 R2 同时是联盟 X1 和 X2 成员的事实，将 R2 加入多个通道：\n这张图显示了网络 N 中与通道 C1 和 C2 有关的如下事实：应用程序 A1 可以使用通道 C1 与 peer P1、P2 和排序服务 O4 进行通信；应用程序 A2 可以使用通道 C1 与 peer P1 和 P2 进行通信，并使用通道 C2 与 peer P2、P3 和排序服务 O4 进行通信。应用程序 A3 可以使用通道 C2 与 peer P3、P2 和排序服务 O4 进行通信。排序服务可以利用通道 C1 和 C2 的通信服务。通道配置 CC1 适用于通道 C1，CC2 适用于通道 C2。\n我们可以看到，R2 是网络中的一个特殊组织，因为它是唯一一个同时是两个应用程序通道成员的组织！它可以在通道 C1 上与组织 R1 进行交易，同时还可以在不同的通道 C2 上与组织 R3 进行交易。\n注意，peer 节点 P2 如何为通道 C1 安装智能合约 S5，并为通道 C2 安装智能合约 S6。peer 节点 P2 为了不同的账本，同时通过不同的智能合约成为两个通道共同的成员。\n这是非常强大的概念——通道同时提供组织隔离的机制和组织间协作的机制。一直以来，此基础设施是由一组独立的组织提供并在其之间共享的。\n同样需要非常注意，peer 节点 P2 的行为受其进行交易的通道的非常不同的控制。具体而言，通道配置 CC1 中的策略规定了当 P2 在通道 C1 中进行交易时，P2 可使用的操作，而通道配置 CC2 中的策略控制 P2 在通道 C2 中的行为。\n同样，这是理想的——R2 和 R1 为通道 C1 的规则达成一致，而 R2 和 R3 位通道 C2 的规则达成一致。这些规则在各自的通道策略中捕获——通道中的组件可以而且必须遵照达成的共识，使用这些策略来强制执行正确的操作。\n类似地，我们可以看到客户端应用程序 A2 限制可以在通道 C1 和 C2 上进行交易。同样，它也将由适当的通道配置中的策略控制。注意，客户端应用程序 A2 和 peer 节点 P2 正在使用混合视觉词汇——线和连接点。您可以看到它们是等效的，是视觉同义词。\n排序服务 细心的读者可能会发现排序服务似乎是一个集中式的组件；它最初用于创建网络，并在网络中连接每一个通道。即使我们把 R1 和 R4 添加到控制排序者的网络配置策略 CN4 中，该节点仍在 R4 的基础设施上运行。在去中心化的世界里，这看上去是错误的！\n别担心！我们的示例网络展示了最简单的排序服务配置，来帮助您理解网络管理核心的概念。事实上，排序服务自己也可以是去中心化的！我们前面提到排序服务可能由不同组织拥有的许多独立节点组成，因此让我们看看如何在示例网络中完成该工作。\n让我们看一下更显示的排序服务节点配置：\n多个组织的排序服务。排序服务由排序服务节点 O1 和 O4 组成。O1 由组织 R1 提供，O4 由组织 R4 提供。网络配置 NC4 为组织 R1 和 R4 的参与者定义网络资源权限。\n我们可以看到，该排序服务完全去中心化——它既在组织 R1 中运行，也在组织 R4 中运行。网络配置策略 NC4 允许 R1 和 R4 在网络资源上享有同等权限。组织 R1 和 R4 的客户端应用程序和 peer 节点，可以通过连接到节点 O1 或节点 O4 来管理网络资源，因为 O1 和 O4 这两个节点的行为一致，就像网络配置 NC4 中策略定义的那样。实践中，来自特定组织的参与者往往使用它们自己组织提供的基础设施，但也并不总是这样。\n去中心化的交易分发 除了作为网络管理核心，排序服务还提供了另一个关键功能——他是交易的分发核心。排序服务是一个从应用程序中收集已背书交易，并将其按序打包进交易区块的组件。随后，这些区块将分发到通道中的每一个 peer 节点。这些提交节点中的每一个都记录交易，不论交易有效或者无效，并相应地更新它们本地的账本副本。\n注意，排序服务节点 O4 在通道 C1 上与它在网络 N 上扮演的角色非常不同。当在通道层面时，O4 的角色是在通道 C1 中收集交易并分发区块。它依据通道配置 CC1 中定义的策略工作。相反，当在网络层面时，O4 的角色是为网络资源提供管理核心，它依据的是网络配置 NC4 中定义的策略。再次注意，这些角色是如何被不同的通道和网络配置各自定义的。这应该对您增强了在 Hyperledger Fabric 中根据配置声明策略的重要性。策略既定义了联盟中每个成员协商一致的行为，也被其所控制。\n我们可以看到，排序服务，像 Hyperledger Fabric 中的其它组件一样，是完全去中心化的组件。不论作为网络管理核心或是通道中区块的分发者，它的节点都可以根据需要分布在网络的多个组织中。\n变更策略 在示例网络的探索过程中，我们已经了解到系统中策略对控制参与者行为的重要性。我们只讨论了一小部分可用的策略，而有很多可以被声明来定义控制行为的各个方面。这些单独的策略会在文档的其它地方进行讨论。\n最终要的是，Hyperledger Fabric 提供了一个唯一强大的策略，它允许网络和通道管理员自行管理测了的变更！基本的哲学是无论在组织内部或之间发生，或是由外部监管者推行，策略变更是一致性的。例如，新的组织可能加入通道，或者已存在的组织拥有的权限可能增加或减少。让我们进一步研究 Hyperledger Fabric 中的变更策略如何实施。\n理解的关键点是策略变更是策略自行管理的。修改策略，或简称 mod_policy，是网络或者通道配置中管理变更的第一种策略。让我们给两个已经在网络中使用 mod_policy 管理变更的简单例子。\n第一个例子是网络初始化的时候。此时，只有组织 R4 被允许管理网络。实践中，这是通过使 R4 成为网络配置 NC4 中定义的唯一拥有网络资源许可的组织来实现的。此外，NC4 的 mod_police 只提及组织 R4——只有 R4 被允许来更改配置。\n然后，我们对网络 N 进行了演进，允许组织 R1 也可以管理网络。R4 通过把 R1 添加到用于通道创建和联盟创建的策略中来做到这一点。由于此更改，R1 能够定义联盟 X1 和 X2，并创建通道 C1 和 C2。R1 对网络配置中的通道和联盟策略具有同等的管理权限。\n但是，R4 可以通过网络配置给 R1 授予更多的权限！R4 可以把 R1 添加到 mod_policy 中，以便 R1 也能够管理网络策略的变更。\n第二个例子比第一个更强大，因为 R1 现在对网络配置 NC4 拥有完全控制权限！这意味着 R1 原则上可以从网络中删除 R4 点管理权限。在实践中，R4 将配置 mod_policy，以便 R4 也需要批准更改，或者 mod_policy 中的所有组织都必须批准更改。有很大的灵活性使 mod_policy 复杂到可以支持所需的任何更改流程。\n这是工作中的 mod_policy——它被允许从基本配置向复杂配置优雅地演进。所有组织参与达成一致的情况总在发生。mod_policy 的行为类似网络或通道配置中的每个其它策略，它定义了一组允许改变 mod_policy 本身的组织。\n在本小节中，我们仅涉及了策略的权限和特定的 mod_policy。在策略主题中将对其进行更详细的讨论，但现在让我们回到王城的网络中！\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#joining-a-peer-to-multiple-channels\n","id":2,"section":"posts","summary":"https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#joining-a-peer-to-multiple-channels 把 peer 加入多个通道 在网络开发的最后阶段，让我们将重点转回到组织 R2。我们可以利用 R2 同时是联盟 X1 和 X2 成员的事实，将 R2 加入多个通道： 这张图显示了","tags":["Hyperledger","Fabric"],"title":"Hyperledger Fabric 1.4 官方文档翻译之六：Key Concepts - Blockchain network (6)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E5%85%ADkey-concepts-blockchain-network-6/","year":"2019"},{"content":" 添加另一个联盟定义 在网络开发的下一阶段，我们介绍组织R3。我们将要为组织 R2 和 R3 提供一个单独应用程序通道，使他们能够互相交易。这个应用程序通道将与之前定义的通道完全分开，因此 R2 和 R3 的交易可以对它们保持私密。\n让我们回到网络层面，为 R2 和 R3 定义一个新联盟 X2：\n组织 R1 或 R4 的网络管理员添加了一个新联盟定义 X2，包括组织 R2 和 R3。这将用于为 X2 定义新通道。\n注意，网络现在有两个联盟定义：组织 R1 和 R2 的 X1，组织 R2 和 R3 的 X2。引入联盟 X2，是为了能够为 R2 和 R3 创建新通道。\n新通道只能被那些在网络配置策略 NC4 中明确标识为拥有相应权限的组织（即 R1 或 R4）创建。这是一个策略的示例，该策略可以区分出可以在网络层面管理资源的组织和可以在通道层面管理资源的组织。看到这些策略在起作用，有助于我们理解为什么 Hyperledger Fabric 具有复杂的分层策略结构。\n在实践中，联盟定义X2已经被添加到网络配置NC4中。我们将在文档的其它地方讨论这些操作的确切机制。\n添加新通道 让我们现在使用新的联盟定义X2创建一个新通道 C2。为了帮助加强您对这个简化通道记号的理解，我们同时使用两种视觉形式——通道 C1 使用蓝色圆圈端点表示，而通道 C2 使用红色连接线表示：\n使用联盟定义 X2 为 R2 和 R3 创建了一个新通道 C2。该通道有完全独立于网络配置 NC4 的通道配置 CC2 和通道配置 CC1。通道 C2 由 R2 和 R3 管理，它们具有 CC2 中策略定义的对 C2 的同等权限。R1 和 R4 在 CC2 中均未被定义任何权限。\n通道 C2 为联盟 X2 提供了私密通讯机制。再次注意，联盟中的组织联合起来是通过什么形式的通道。通道配置 CC2 现在包含管理通道资源的策略，通过通道 C2 给组织 R2 和 R3 分配管理权限。它仅由 R2 和 R3 管理，R1 和 R4 在通道 C2 中没有权限。例如，随后可以更新通道配置 CC2 以添加组织来支撑网络增长，但这些只能由 R2 或 R3 完成。\n注意，通道配置 CC1 和 CC2 如何保持彼此完全独立，并与网络配置 NC4 完全独立。再次，我们看到 Hyperledger Fabric 网络的去中心化特性；通道 C2 一旦创建，它将被组织 R2 和 R3 独立于其它网络元素来管理。通道策略总是保持彼此独立，并只能由有权在通道中这样做的组织进行更改。\n随着网络和通道的发展，网络和通道的配置也将随之发展。这是一个通过受控的方式完成的过程——涉及配置交易，这些交易包括这些配置的更改。每个配置的更改都会导致一个新的配置区块交易生成，在本主题的后面，我们将看到这些区块如何被验证和接受，以便分别创建更新的网络和通道配置。\n网络和通道配置 在整个示例网络中，我们看到网络和通道配置的重要性。这些配置非常重要，因为它们封装了网络成员达成一致的策略，这些策略对控制访问网络资源提供了共享参考。网络和通道配置还包含有关网络和通道组成的事实，例如联盟的名称及其组织。\n例如，当使用排序服务节点 O4 首次生成网络时，其行为被网络配置 NC4 控制。NC4 的初始配置只包含允许组织R4管理网络资源的策略。随后，NC4 被更新为还允许 R1 管理网络资源。进行此更新后，组织 R1 或 R4 中连接到 O4 的任何管理员将拥有网络管理权限，因为这是网络配置 NC4 中策略许可的。在内部，排序服务中的每一个节点都会记录网络配置中的每个通道，因此在网络层面有每个通道创建的记录。\n这意味着，虽然排序服务节点 O4 是创建联盟 X1 和 X2 以及通道 C1 和 C2 的参与者，但是网络的智能包含在 O4 遵循的网络配置 NC4 中。只要 O4 表现良好，并且在处理网络资源时正确地实施在 NC4 中定义的策略，我们的网络将做出所有组织都同意的行为。在许多方面，NC4 都比 O4 更重要，因为它最根本地控制网络访问。\n相同的原则适用于有关 peer 的通道配置。在我们的网络中，P1 和 P2 都是好的执行者。当 peer 节点 P1 和 P2 与客户端应用程序 A1 或 A2 交互时，它们每个都使用通道配置 CC1 中定义的策略控制来控制对通道 C1 资源的访问。\n例如，如果 A1 想要访问在 peer 节点 P1 或 P2 上的智能合约链码 S5 时，每个 peer 节点使用其 CC1 的副本来确定 A1 可以访问的操作。例如，根据 CC1 中的策略定义，允许 A1 从账本 L1 上读写数据。稍后我们将看到在通道及其通道配置 CC2 中的参与者有同样的模式。再次，我们可以看到，peer 和应用程序是网络中的关键角色。但它们在通道中的行为更多地由通道配置策略决定，而不是其它任何因素。\n最后，了解网络和通道配置如何在物理上存在将很有帮助。我们可以看到，网络和通道配置在逻辑上是唯一的——网络有一个，每个通道有一个。这非常重要，访问网络或通道的每一个组件必须对授予不同组织的权限有共同的理解。\n即使逻辑上是一个配置，但实际上它被构成网络或通道的每一个节点复制并保持一致。例如，在我们的网络中 peer 节点 P1 和 P2 都拥有通道配置 CC1 的副本，而到网络完成时， peer 节点 P2 和 P3 将都拥有通道配置 CC2 的副本。类似地，排序服务节点 O4 拥有网络配置的副本，但在多节点配置中，每一个排序服务节点都将拥有它自己的网络配置副本。\n网络和通道配置都使用同样的区块链技术保持一致，该区块链技术用来对用户交易而非配置交易。要改变网络或通道配置，管理员必须提交配置交易来改变网络或通道配置。它必须由恰当的策略中确定负责配置变更的组织签名。该策略被称为 mod_policy，我们将稍后讨论它。\n的确，排序服务节点运行着一个迷你区块链，通过我们前面提到的系统通道连接。排序服务节点使用系统通道分发网络配置交易。这些交易用于在每个排序服务节点上合作维护网络配置的一致性副本。类似的方式，应用程序通道中的 peer 节点可以分发通道配置交易。同样的，这些交易用于在每个 peer 节点上维护通道配置的一致性副本。\n逻辑上唯一性与物理上分布式之间的这种平衡是 Hyperledger Fabric 中常见的模式。例如，像网络配置，逻辑上是单一的，但实际上是物理上在一组排序服务节点中进行复制的。我们还看到通道配置、账本以及某种程度上的智能合约，它们安装在多个地方，但它们的接口逻辑上存在于通道层面。您会在 Hyperledger Fabric 中一次又一次地看到这种模式，它使得 Hyperledger Fabric 既去中心化又可管理。\n添加另一个 peer 既然组织 R3 能够完全参与通道 C2，让我们把它的基础组件添加仅该通道中。我们将一次添加 peer 及其账本的本地副本、智能合约和客户端应用程序，而不是每次只添加一个组件！\n让我们看一下添加了组织 R3 的组件的网络：\n这张图显示了与网络 N 中的通道 C1 和 C2 的如下事实：客户端应用程序 A1 和 A2 可以使用通道 C1 与 P1、P2 和排序服务 O4 通信；客户端应用程序 A3 可以使用通道 C2 与 P3 和排序服务 O4 通信。通信服务 O4 可以利用通道 C1 和 C2 的通信服务。通道配置 CC1 适用于通道 C1，CC2 适用于通道 C2。\n首先，请注意，由于 peer 节点 P3 连接到通道 C2，因此它对那些使用通道 C1 的 peer 节点有不同的账本 L2。账本 L2 的有效作用域是通道 C2。账本 L1 是完全独立的，它的作用域是通道 C1。这是有道理的——通道 C2 的目的是在联盟 X2 的成员之间提供私密通信，账本 L2 是其交易的私密存储。\n类似的方式，在peer 节点 P3 上安装并在通道 C2 上实例化的智能合约 S6，用于提供对账本 L2 的受控访问。应用程序 A3 限制可以使用通道 C2 调用由智能合约 S6 提供的服务，生成可以在网络中被每个账本 L2 接受的交易。\n此时，我们有了一个定义了两个完全独立通道的网络。这些通道为组织之间的相互交易提供了独立管理的设施。同样地，这是去中心化的工作，我们有一个在控制和自治之间的平衡。这是通过应用于受到不同组织控制和影响的通道策略来实现的。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#adding-another-consortium-definition\n","id":3,"section":"posts","summary":"添加另一个联盟定义 在网络开发的下一阶段，我们介绍组织R3。我们将要为组织 R2 和 R3 提供一个单独应用程序通道，使他们能够互相交易。这个应用程序通道","tags":["Hyperledger","Fabric"],"title":"Hyperledger Fabric 1.4 官方文档翻译之五：Key Concepts - Blockchain network (5)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%BA%94key-concepts-blockchain-network-5/","year":"2019"},{"content":" 网络完成 回想一下，我们的目标是为联盟 X1（组织 R1 和 R2）创建一个通道。网络开发的下一节会看到组织 R2 把它的基础设施添加到网络中。\n让我们看一下网络是如何演进的：\n通过增加组织 R2 的基础设施，网络得到了发展。具体来说，R2 添加了 peer 节点 P2，该 peer 节点托管账本 L1 的副本和链码 S5。P2 也与应用程序 A2 一样加入了通道 C1。A2 和 P2 使用来自 CA2 的证书进行标识。所有这些意味着应用程序 A1 和 A2 都可以使用 peer 节点 P1 或 P2 在 C1 上调用 S5。\n我们可以看到组织 R2 在通道 C1 上添加了一个 peer 节点 P2。P2 还托管账本 L1 和智能合约 S5 的副本。我们可以看到 R2 还添加了可以通过通道 C1 连接到网络的客户端应用程序 A2。为此，组织 R2 中的管理员已创建 peer 节点 P2，并将其加入通道 C1，方法与 R1 中的管理员相同。\n我们已经建立了第一个运营网络！在网络开发的现阶段，我们拥有一个通道，组织 R1 和 R2 可以彼此进行完整交易。具体来说，这意味着应用程序 A1 和 A2 可以使用智能合约 S5 和账本 L1 在通道 C1 上生成交易。\n生成和接受交易 与总是持有账本副本的 peer 节点相反，我们看到存在两种不同的 peer 节点：持有智能合约的节点和不持有智能合约的节点。（译者按：即所有的 peer 节点都持有账本的副本，但不是所有的 peer 节点都持有智能合约的副本。）在我们的网络中，每个 peer 都持有一个智能合约的副本，但是在较大的网络中，将有更多的 peer 节点不持有智能合约的副本。peer 只能在安装了智能合约的情况下运行它，但是 peer 可以连接到通道，以了解智能合约的接口。\n您不应该把不持有智能合约的 peer 节点视为低级节点。持有智能合约的 peer 节点确实有一种特殊的能力——帮助生成交易。注意，所有的 peer 节点都能够在它们的账本 L1 的副本上，验证、接受或拒绝交易。然而，只有安装智能合约的 peer 节点才能够参与到交易背书的过程中，这对生成有效交易至关重要。\n在本篇文章中，我们无需关心交易如何生成、分发和接受的确切细节，已足够了解我们拥有一个区块链网络，组织 R1 和 R2 可以将信息和流程共享为账本已捕获的交易。在其它主题中，我们将学习到更多有关交易、账本、智能合约的内容。\npeer 的类型 在 Hyperledger Fabric 中，尽管所有 peer 都相同，但是它们可以根据网络的配置方式承担多个角色。现在，我们对典型的网络拓扑有了足够的了解，可以描述这些角色。\n 提交节点（Committing peer）。通道中的每个 peer 节点都是提交节点。它接收生成的交易的块，并随后验证它们，然后再将它们提交到 peer 节点的账本副本作为追加操作。\n 背书节点（Endorsing peer）。如果安装了智能合约，每个 peer 都可以成为背书 peer 。然而，实际上要成为背书 peer，peer 上的智能合约必须被客户端应用程序用来生成数字签名的交易响应。\n  智能合约的背书策略标识了组织，其 peer 应先对生成的交易进行数字签名，然后才能将其接受到提交的 peer 的账本副本中。\n这是 peer 的两种主要类型。peer 可以采用其他两个角色：\n 领导节点（Leader peer）。当组织在一个通道中有多个 peer 时，领导节点是负责将交易从排序者分发到组织中其它提交节点的节点。peer 可以参与静态或动态的领导选择。  因此，从领导者的角度思考两组 peer 是有帮助的——那些具有静态领导者选择的 peer 和那些具有动态领导者选择的 peer。对于静态组，零个或多个 peer 可以被配置为领导者。对于动态组，只有一个 peer 将被选择为领导者。此外，在动态组中，如果领导节点失效，那么其余 peer 将重新选择领导者。\n这意味着组织的 peer 可以有一个或多个领导者连接到排序服务。这可以帮助提高在大型网络中处理大量交易的弹性和可伸缩性。\n 锚节点（Anchor peer）。如果 peer 节点需要与另一个组织中的 peer 通信，它可以使用该组织通道配置中定义的锚节点中的一个。一个组织可以为其定义零个或多个锚节点，并且锚节点可以帮助处理不同的跨组织通信场景。  注意，一个 peer 可以同时是一个提交节点、背书节点、领导节点和锚节点。只有锚节点是可选的——处于所有实际目的，总会有一个领导节点，至少有一个背书节点，至少有一个提交节点。\n安装而不是实例化 和组织 R1 一样的方法，组织 R2 必须将智能合约 S5 安装到它的 peer 节点上。这很明显——如果应用 A1 或 A2 希望在 peer 节点 P2 上使用 S5 生成交易，那么 S5 必须存在，安装是确保这发生的机制。此时，peer 节点 P2 拥有智能合约和账本的物理副本，像 P1 一样，它可以在其账本 L1 上同时生成和接受交易。\n然而，与组织 R1 相比，组织 R2 不需要在通道 C1 上实例化智能合约 S5。这是因为 S5 已经被组织 R1 在通道中实例化了。实例化只需要发生一次。随后加入通道的任何 peer 都知道智能合约 S5 在该通道中可用。这些反映了这样一个事实，账本 L1 和智能合约实际上以物理的形式存在于 peer 节点上，以逻辑的形式存在于通道上，R2 只是将另一个 L1 和 S5 的物理实例添加到网络上。\n在我们的网络中，我们可以看到通道 C1 连接了两个客户端应用程序，两个 peer 节点和一个排序服务。由于只有一个通道，所以只有一个逻辑账本与这些组件进行交互。peer 节点 P1 和 P2 有账本 L1 完全相同的副本。智能合约 S5 的副本通常使用同样的编程语言完全相同地实现，但如果不同，他们必须在语义上等效。\n我们可以看到，小心地将 peer 添加到网络可以帮助支持增长的吞吐量、稳定性和弹性。例如，网络中更多的 peer 允许更多的应用程序连接到它；如果发生计划内或计划外的停机，组织中更多的 peer 将提供额外的弹性。\n这一切都意味着，可以配置支持各种业务目标的复杂拓扑——网络可达到理论上没有限制的规模。此外，单个组织中的 peer 有效地发现并彼此通信的技术机制——gossip 协议——将容纳大量 peer 节点，以支持这样的拓扑。\n谨慎使用网络和通道策略可以使甚至大型网络都得到良好的管理。组织可以自由地将 peer 节点加入到网络，只要他们遵守网络约定的策略即可。网络和通道策略在自治和控制之间建立平和，这是去中心化网络的特征。\n简化视觉词汇 现在，我们将简化用于表示我们示例区块链网络的视觉词汇。随着网络规模的增长，最初帮助我们理解通道的线将变得很繁琐。想象一下，如果我们添加另一个 peer 或客户端应用程序，或者另一个通道，图将变得多么复杂？\n这就是我们将在一分钟内做的事情，在我们这样做之前，让我们简化视觉词汇。这是到目前为止我们开发的网络的简化表示：\n这张图展示了与网络 N 有关的如下事实：客户端应用程序 A1 和 A2 可以使用通道 C1 与 peer P1、P2 和排序者 O4 进行通信。peer 节点 P1 和 P2 可以使用通道 C1 点通信服务。排序服务 O4 可以利用通道 C1 的通讯服务。通道配置 CC1 应用于通道 C1。\n注意，这张网络已经用连接点代替通道线进行了简化，显示为包含通道数字的蓝色圆圈。没有信息损失。这个表示更具有伸缩性，因为它消除了交叉线。这使我们可以更清晰地表示更大的网络。我们通过聚焦于组件和通道之间的连接点，而不是通道本身的方式，达到了这样的简化。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#network-completed\n","id":4,"section":"posts","summary":"网络完成 回想一下，我们的目标是为联盟 X1（组织 R1 和 R2）创建一个通道。网络开发的下一节会看到组织 R2 把它的基础设施添加到网络中。 让我们看一下网","tags":["Hyperledger","Fabric"],"title":"Hyperledger Fabric 1.4 官方文档翻译之四：Key Concepts - Blockchain network (4)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E5%9B%9Bkey-concepts-blockchain-network-4/","year":"2019"},{"content":" peer 和账本 现在，让我们使用通道把区块链网络和组织连接起来。在网络开发的下一阶段，我们可以看到网络 N 获得了两个新组件，即 P1 和账本实例 L1。\n Peer 节点 P1 已加入通道 C1，P1 物理上托管账本 L1 的副本。P1 和 O4 可以使用 C1 相互通信。*  peer 节点是托管区块链账本副本的网络组件！最后，我们开始看到一些可识别的区块链组件！P1 在网络中的目的纯粹是托管账本 L1 的副本，以供其他人访问。我们可以认为 L1 物理上托管在 P1 上，但逻辑上托管在通道 C1 上。当我们向通道添加更多 peer 时，我们会更清楚地看到这个想法。\nP1 配置的关键部分是 CA1 发出的 X.509 身份，该身份将 P1 与组织 R1 相联。P1 一旦启动，它就可以使用排序者 O4 加入 C1。当 O4 收到加入申请时，将使用 CC1 来确定 P1 在此通道上的权限。例如，CC1 决定 P1 是否可以在 L1 上进行读写操作。\n注意，peer 如何被拥有它们的组织加入到通道中，以及虽然我们只添加了一个 peer，但是将看到网络中的多个通道上可以有多个 peer 节点。我们马上将看到 peer 可以扮演不同角色。\n应用程序和智能合约链码 现在，通道 C1 上有一份账本，我们可以开始连接客户端应用程序，来使用由账本、peer 提供的一些服务！\n注意，网络是如何成长的：\n智能合约 S5 已安装到 P1 上。组织 R1 中的客户端应用程序 A1 可以使用 S5 通过 peer 节点 P1 访问账本。A1，P1 和 O4 都已加入通道 C1，即它们都可以利用该通道提供的通信设施。\n在网络开发的下一个阶段，我们可以看到客户端应用程序 A1 可以使用通道 C1 连接到特殊的网络资源——在这个例子中，A1 可以连接 peer 节点 P1 和排序节点 O4。再次看到通道对网络和组织组件之间通信非常重要。就像 peer 和排序者，客户端应用程序将拥有与组织关联的身份。在我们的示例中，客户端应用程序 A1 与组织 R1 关联；虽然它在 Fabric 区块链网络之外，但仍通过通道 C1 连接到它。\n现在，看起来 A1 可以直接通过 P1 访问账本 L1，但实际上，所有访问都是通过称为智能合约链码 S5 的特殊程序进行管理的。S5 定义了所有对账本的常见访问模式；S5 提供了一套明确定义的方式，可以查询或更新账本 L1。简而言之，客户端应用程序 A1 必须通过智能合约 S5 才能到达账本 L1！\n智能合约联盟可以由每个组织中的应用程序开发人员创建，以实现联盟成员共享业务流程。智能合约用于帮助生成交易，这些交易将被有序地分发刀网络中的每个节点。 智能合约必须被安装并实例化。\n安装智能合约 智能合约 S5 开发完成后，组织 R1 中的管理员必须将其安装到 peer 节点 P1 上。这是一个简单的操作；执行后，P1 完全了解 S5。具体来说，P1 可以看到 S5 的实现逻辑——用于访问账本 L1 的程序代码。我们将其与只描述输入和输出，不考虑其实现的 S5 接口进行对比，\n当组织在一个通道中有多个 peer 时，它可以选择 peer 进行智能合约的安装。它不需要在每个 peer 上安装智能合约。\n实例化智能合约 但是，仅仅因为 P1 已经安装了 S5，连接到通道 C1 的其他组件却没有意识到；它必须首先在通道 C1 上实例化。在我们的示例中，它只有一个 peer 节点 P1，组织 R1 中的管理员必须使用 P1 在通道 C1 上实例化 S5。实例化之后，通道 C1 上的每个组件都知道 S5 的存在。在我们的示例中，这意味着 S5 现在可以由客户端应用程序 A1 调用！\n请注意，尽管通道上的每个组件现在都可以访问 S5，但它们无法看到其程序逻辑。这对于已安装它的那些节点仍然是私有的。在我们的示例中，这些节点就是 P1。从概念上讲，这意味着实例化的是智能合约接口，而不是安装的智能合约实现。加深理解，安装智能合约显示了我们如何将其物理托管在 peer 上，而实例化智能合约则显示了我们如何将其视为逻辑上由通道托管。\n背书策略 实例化提供的最重要的附加信息是背书策略。它描述了哪些组织必须在其它组织在其账本副本上接受交易前批准交易。在我们的示例网络中，交易只有被 R1 或 R2 认可后，才可以在账本 L1 上被接受。\n实例化的操作把背书策略放在通道配置 CC1 中。通道的任何成员都可以访问它。您可以在事务流主题中阅读有关背书策略的更多信息 。\n调用智能合约 智能合约安装在 peer 节点上并在通道上实例化后，即可被客户端应用程序调用。客户端应用程序通过向智能合约背书策略指定的组织所拥有的 peer 发送交易预案来完成此任务。交易预案作为智能合约的输入，智能合约使用它来生成背书交易的响应，该应答由 peer 节点返回给客户端应用程序。\n这些交易响应跟交易预案打包在一起，形成了一个完全背书交易，它可以分布在整个网络。稍后我们将更详细地介绍这一点。现在，这已足够理解应用程序是如何调用智能合约生成背书交易的了。\n在网络开发的这个阶段，我们可以看到组织 R1 完全参与网络。它的应用程序——从 A1 开始——可以通过智能合约 S5 访问账本 L1，来生成会被 R1 背书的交易。由于它们遵守背书策略，所以能够被接受到账本。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#peers-and-ledgers\n","id":5,"section":"posts","summary":"peer 和账本 现在，让我们使用通道把区块链网络和组织连接起来。在网络开发的下一阶段，我们可以看到网络 N 获得了两个新组件，即 P1 和账本实例 L1。 Peer 节点","tags":["Hyperledger","Fabric"],"title":"Hyperledger Fabric 1.4 官方文档翻译之三：Key Concepts - Blockchain network (3)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%B8%89key-concepts-blockchain-network-3/","year":"2019"},{"content":" 添加网络管理员 最初，NC4 被配置为仅允许 R4 的用户拥有网络管理权限。下一阶段，我们将允许组织 R1 的用户管理网络。让我们看看网络如何演进：\n组织 R4 更新网络配置，使组织 R1 也成为管理员。此后，R1 和 R4 在网络配置上享有同等的权利。\n我们看到添加了一个新的组织 R1 作为管理员——R1 和 R4 现在对网络享有同等权利。我们还可以看到证书颁发机构 CA1 已被添加——它可以用于标示用户来自 R1 组织。此后，来自 R1 和 R4 的用户都可以管理网络。\n虽然排序节点 O4 运行在 R4 的基础设施上，但是只要 R1 获得了网络访问权限，就对其具有共享管理权限。这意味着，R1 或 R4可以更新网络配置 NC4 来允许 R2 组织拥有网络操作的子集。这样，即使 R4 正在运行排序服务，并且R1 对其拥有完全的管理权限，R2 仍对创建新联盟拥有有限权限。\n最简单的形式，排序服务在网络中是单点，这就是您在示例中看到的。排序服务通常是多节点的，并且可以被配置为在不同组织的不同节点中。例如，我们可以在 R4 中运行 O4，同时将其连接到组织 R1 中的独立排序节点 O2。这样，我们将拥有一个多站点、多组织的管理结构。\n在本篇文章的稍后部分，我们将多讨论一点排序服务，但现在只将排序服务当作管理重点，它给不同的组织提供网络的受控访问权限。\n定义联盟 虽然现在网络可以由 R1 和 R4管理，但几乎没有什么可以做的。我们需要做的第一件事是定义一个联盟。这个词的字面意思是“拥有共同命运的团体”，所以对于区块链网络中的一组组织来说是一个适当的选择。\n让我们看看如何定义一个联盟：\n网络管理员定义了一个联盟 X1，包含 R1 和 R2 两个组织成员。该联盟定义存储在网络配置 NC4 中。CA1 和 CA2 是这些组织各自的证书颁发机构。\n由于 NC4 的配置方式，只有 R1 和 R4 可以创建新的联盟。这张图展示了新联盟 X1 的加入，该联盟将 R1 和 R2 定义为它的组成组织。我们还可以看到 CA2 被添加，用来标示来自 R2 的用户。注意，一个联盟可以有任意数量的组织成员——我们刚刚展示了两个，因为它是最简单的配置。\n为什么联盟重要？我们可以看到，一个联盟定义了网络中彼此共享交易需求的组织集合——在这个例子中是 R1 和 R2。如果组织有共同的目标，将它们组合在一起会很有意义，而这确实正在发生。\n网络虽然由一个单独的组织启动，但现在由更大的一组组织所控制。我们可以以这种方式启动网络，让 R1、R2 和 R4 共享控制权，但是这让其更容易理解。\n现在，我们将使用联盟 X1 创建 Hyperledger Fabric 区块链中非常重要的一部分——通道。\n为联盟创建通道 让我们创建 Hyperledger Fabric 区块链中的关键部分——通道。通道是主要的通信机制，联盟的成员可以通过该机制相互通信。网络中可以有多个通道，但现在我们将从一个开始。\n让我们看看第一个通道是如何被加入网络的：\n使用联盟定义 X1 为 R1 和 R2 创建了通道 C1。通道由完全独立于网络配置的通道配置 CC1 控制，CC1 由对 C1 拥有同等权利的 R1 和 R2 管理。R4 在 CC1 中没有任何权利。\n通道 C1 为联盟 X1 提供了专用的通信机制。我们可以看到通道 C1 已连接到排序服务 O4 ，但是没有附加任何内容。在网络开发的下一阶段，我们将连接组件，例如客户端应用程序和 peer 节点。但是在这一点上，通道代表着未来连接的潜力。\n即使通道 C1 是网络 N 的一部分，也可以从中分区出来。还要注意，组织 R3 和 R4 不在这个通道里——它只为 R1 和 R2 之间的交易处理。在上一步中，我们看到 R4 如何授权 R1 创建新联盟的权限。值得一提的是 R4 还允许 R1 创建通道！在这张图中，可能是组织 R1 或 R4 创建了通道 C1。同样，请注意，一个通道可以拥有任意数量的组织——我们刚刚展示了两个，因为它是最简单的配置。\n再次注意，通道 C1 有相较于网络配置 NC4 完全独立的配置 CC1。CC1 包含通道 C1 上 R1 和 R2 管理权限的策略（正如我们看到的），R3 和 R4 在这个通道上没有权限。如果 R3 和 R4 被 R1 或 R2 添加到通道配置 CC1 中的适当策略，则 R3 和 R4 只能与 C1 交互。一个示例定义谁可以把一个新组织加入到通道中。特别注意，R4 不能把自己加入到通道 C1 中——它只能由 R1 或 R2 授权。\n为什么通道如此重要？通道有用是因为它们为联盟成员间的私有通讯和私有数据提供了一种机制。通道提供网络和其它通道的隐私性。Hyperledger Fabric 在这方面非常强大，因为它允许组织共享基础设施并同时保持其私有状态。这里没有矛盾——网络中不同的联盟将需要适当共享不同的信息和处理过程，通道提供一种有效的机制来做到这一点。通道可有效共享基础架构，同时保持数据和通信的隐私。\n我们还可以看到，一旦创建了一个通道，它实际上就是“脱离网络”。从此时到未来，只有在通道配置中明确指定的组织才能对其进行控制。同样，从此时开始对网络配置 NC4 的任何更新都不会直接影响通道配置 CC1；例如，如果联盟定义 X1 更新，它将不会影响通道 C1 的成员。通道之所以有用，是因为它们允许构成通道的组织之间进行隐私通信。此外，通道中的数据与网络的其余部分（包括其他通道）完全隔离。\n顺便说一句，还有一个特殊的系统通道，供排序服务使用。它的行为与常规通道完全相同，因此有时会称为应用程序通道。 我们通常不需要担心这个通道，但我们将在本篇文章的稍后部分对此讨论更多。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#adding-network-administrators\n","id":6,"section":"posts","summary":"添加网络管理员 最初，NC4 被配置为仅允许 R4 的用户拥有网络管理权限。下一阶段，我们将允许组织 R1 的用户管理网络。让我们看看网络如何演进： 组织 R4 更","tags":["Hyperledger","Fabric"],"title":"Hyperledger Fabric 1.4 官方文档翻译之二：Key Concepts - Blockchain network (2)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%BA%8Ckey-concepts-blockchain-network-2/","year":"2019"},{"content":" 上一篇介绍了 Hugo 的安装，以及如何在 GitHub Page 上进行部署。这一篇将介绍如何在独立的服务器上部署站点。\n在服务器上部署站点，可以最大程度地自由发挥。首先，需要一台服务器，博客不需要太高的配置，入门级云服务器即可。然后，需要一个域名，这是您江湖上行走的ID，自己喜欢就好，不推荐暂时不能备案的（如 .org、.name 等）。此外，还需要 DNS 解析服务，有的域名商会在卖域名时附赠这项服务。总结一下，需要：\n 云服务器 域名 DNS 服务  Hugo 生成的是静态站点，推荐使用 nginx 作为博客的 web 服务器。\n下面，就开始部署吧。\n查看系统信息 $ cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) $ uname -r 3.10.0-862.el7.x86_64  安装 nginx 安装依赖 gcc-c++ 是 nginx 源码编译需要的 gcc 环境。\npcre、pcre-devel、zlib、zlib-devel、openssl、openssl-devel 是 nginx 源码编译依赖的库。\nyum -y install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel  创建 nginx 用户 给 nginx 服务分配单独的用户进行操作，以隔离风险。\nuseradd nginx su nginx  安装 nginx 下载最新版本的 nginx 源码。配置 configure 参数，把 nginx 安装在 nginx 的用户目录 opt/ 下，并设置 worker 进程 的默认用户为 nginx 。\nmkdir $HOME/download $HOME/opt cd ~/download wget https://nginx.org/download/nginx-1.16.1.tar.gz tar zxf nginx-1.16.1.tar.gz cd nginx-1.16.1 ./configure --prefix=/home/nginx/opt/nginx --user=nginx make \u0026amp; make install  配置环境变量 为 nginx 设置用户的环境变量。首先，在用户根目录下创建 bin/ 目录，用于存放所有应用程序的软链接。再将 bin/ 目录加入 PATH，并立即生效。最后，在 bin/ 目录下创建 nginx 的软链接。\nmkdir $HOME/bin echo -e '\\nPATH=/home/nginx/bin:$PATH\\n' \u0026gt;\u0026gt; /home/nginx/.bash_profile source /home/nginx/.bash_profile ln -s /home/nginx/opt/nginx/sbin/nginx /home/nginx/bin  启动 nginx 非超级用户不能监听1024以下的端口。所以，需要让 nginx 监听 8080 端口，再让 firewall 将 80 端口 的流量转发至 8080 端口。\n编辑 nginx 配置文件 ... server { listen 8080; # 把80改为8080 ... } ...  设置端口转发 # 使用 root 用户操作，需要 root 权限 su root systemctl start firewalld.service firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 --permanent firewall-cmd --reload  启动 nginx su nginx nginx  此时，浏览器打开，就能够看到 nginx 的欢迎页了。\n上传静态站点 将由 Hugo 生成的站点上传至服务器，推荐在 nginx 用户的根目录下，这样比较方便。关于如何使用 Hugo 生成静态站点，请查看上一篇。\n配置站点 再次编辑 nginx 的配置文件，设置站点域名、路由等。\nserver { listen 8080; server_name domain_name; # 博客域名 location / { root /path/to/site; # 博客站点的目录，注意要使用绝对路径 index index.html; } ... }  重新启动 nginx：\n$ nginx -s reload  此时，浏览器打开 服务器的 IP 地址，就能够看到您的博客首页了。\nDNS 解析 在 DNS 解析服务上，将 域名 指向 服务器的 IP 地址。浏览器打开 域名，就可以看到博客页面了。\n网站备案 注意，需要尽快进行网站备案，否则，很快就看不到您的网站了。\n软件版本 本文涉及到的软件版本如下：\n CentOS Linux release 7.5.1804 (Core) nginx 1.16.1 Hugo 0.60.1  参考 https://www.cnblogs.com/remyyoung/p/11244840.html\nhttps://www.cnblogs.com/boonya/p/7907999.html\n","id":7,"section":"posts","summary":"上一篇介绍了 Hugo 的安装，以及如何在 GitHub Page 上进行部署。这一篇将介绍如何在独立的服务器上部署站点。 在服务器上部署站点，可以最大程度地自由发挥。首先，","tags":["hugo","nginx"],"title":"Hugo 博客搭建之二：部署在服务器上","uri":"https://devjue.github.io/2019/12/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E4%BA%8C%E9%83%A8%E7%BD%B2%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/","year":"2019"},{"content":" 安装 Hugo mac 推荐使用 brew 进行安装：\n$ brew install hugo  windows 推荐从 GitHub 直接下载最新的稳定的二进制版本。然后，将其加入环境变量。\n源码安装 如果网络条件良好，也可以使用源码进行安装。因为 Hugo 是由 Go 语言编写的，所以需要 Go 语言环境。自从 Hugo 0.48 以后，Hugo 需要 Go 1.11 以上版本。把 Hugo 克隆在 GOPATH 的 src/ 目录下，并使用 Go 编译安装：\n$ mkdir $GOPATH/src $ cd $GOPATH/src $ git clone git@github.com:gohugoio/hugo.git $ cd hugo $ go install  生成的 hugo 可执行文件在 GOPATH/bin/ 目录下。\n生成站点 使用 hugo new site 命令生成新的站点，/path/to/site/ 是新站点的目录。\n$ hugo new site /path/to/site  创建文章 创建第一篇文章：\n$ cd /path/to/site $ hugo new post/hello_world.md  hello_world.md 会出现在 /path/to/site/content/post/ 目录下。\n安装皮肤 Hugo官网 有很多主题可供选择。选择您最喜欢的一款，下载到本地 theme 目录下。推荐使用 git clone 克隆项目，方便以后更新主题。但如果考虑到以后需要使用 GitHub 对博客版本进行管理，更推荐使用 git submodule add 将主题项目作为子模块添加。这部分不是本文讨论的重点，如果感兴趣，可以阅读《Hugo博客搭建之三：使用 GitHub 对博客版本进行管理》了解更多。本文还是介绍使用 git clone 克隆项目的方法。例如，我选择的是 pure :\n$ git clone git@github.com:xiaoheiAh/hugo-theme-pure.git themes/pure  运行 Hugo 使用 hugo server 启动 Hugo。\n$ hugo server -t pure -D   -t（--theme）指定主题名称，pure 是我们刚下载的主题的名字，如果您下载的是其它主题，则使用 theme 目录下该主题的名字。 -D（--buildDrafts）指生成包括被标记为 draft 的文章。文章在由 hugo new 命令生成后，没有进行任何编辑前，都被标记为 draft。如下所示，在新文章的头部：\n--- ... draft: true ---   刚才我们生成的第一篇文章 hello_world.md 也是被标记为 draft 的文章，如果启动 Hugo 时没有参数 -D，浏览器将不会显示任何文章。\n浏览器打开：http://localhost:1313。\n部署 Hugo 由于 Hugo 生成的是静态网站，所以可以部署在 GitHub Page 上。当然，它也可以部署在独立的服务器上。\n在 GitHub Page 上部署的好处是免费、操作简单，但访问速度有时候可能比较慢。可以使用默认域名，形如 yourname.github.io，也可以使用自己的域名。注意，下文出现的所有 yourname 都与此处一致。\n在独立的服务器上部署会比前者麻烦，并且需要一点服务器操作经验，但其容量、访问速度等限制都取决于服务器本身。此外，只能使用自己的域名。\n本篇文章将介绍在 GitHub Page 上部署站点，下一篇将介绍在独立的服务器上部署站点。\n创建 GitHub 仓库 首先，在 GitHub 上创建形如 yourname.github.io 的仓库。如下图所示（在此使用 devjue 作为 yourname ）：\n生成静态页面 在本地 /path/to/site/ 目录下，执行 hugo 命令：\n$ cd /path/to/site $ hugo -t pure -b \u0026quot;https://yourname.github.io/\u0026quot;   -b（--baseUrl）指定站点域名。   注意，以上命令不会生成被标记为 draft 的文章。\n 此时，Hugo 已经将所有的静态页面创建在 public/ 目录下。\n初始化仓库 在本地 /path/to/site/public/ 目录下，初始化仓库：\n$ cd /path/to/site/public $ git init $ git remote add origin git@github.com:yourname/yourname.github.io.git $ git add README.md $ git commit -m \u0026quot;init blog\u0026quot; $ git push -u origin master  如果一切顺利，浏览器打开 https://yourname.github.io/ ，就会看到您的站点了。\n软件版本 本文涉及到的软件版本如下：\n macOS Catalina 10.15.1 Windows 10 专业版 Hugo 0.60.1 hugo-theme-pure master at 2019/12/05  参考 https://www.gohugo.org/\nhttps://gohugo.io/getting-started/quick-start/\nhttps://pages.github.com/\n","id":8,"section":"posts","summary":"安装 Hugo mac 推荐使用 brew 进行安装： $ brew install hugo windows 推荐从 GitHub 直接下载最新的稳定的二进制版本。然后，将其加入环境变量。 源码安装 如果网络条件良好，也可以使用源","tags":["hugo"],"title":"Hugo 博客搭建之一：部署在 GitHub Page 上","uri":"https://devjue.github.io/2019/12/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E4%B8%80%E9%83%A8%E7%BD%B2%E5%9C%A8github-page%E4%B8%8A/","year":"2019"},{"content":" 区块链 这篇文章将在概念层面讲述 Hyperledger Fabric 如何允许组织在形成区块链网络方面进行协作。如果您是架构师、管理员或开发者，则可以利用本篇文章深入了解 Hyperledger Fabric 区块链网络中的主要结构和流程组件。本篇文章将使用一个可管理的工作示例来介绍区块链网络中的所有主要组件。当了解这个示例后，您可以在文档的其它地方阅读更多有关这些组件的详细信息，或者尝试建立一个示例网络。\n阅读这篇文章并了解策略的概念后，您将对为控制一个已部署的区块链网络，组织需要建立策略这样的决定有深入了解。您还将了解组织是如何使用已声明的策略进行网络演进的管理，这些策略是 Hyperledger Fabric 的重要功能。简言之，您将了解 Hyperledger Fabric 的主要技术组件及组织需要对其做出的决策。\n什么是区块链网络 区块链网络是一种技术基础设施，它为应用程序提供账本和智能合约（链码）服务。首先，智能合约用于生成交易，这些交易随后会被分发到网络中的每一个 peer（译者按：由于“peer”已成为专有名词，本文将直接使用“peer”，而不将其翻译为“对等节点”）节点，交易被永远不变地记录在 peer 节点的账本副本上。应用程序的用户可以是使用客户端应用程序的终端用户或区块链网络的管理员。\n大多数情况下，多个组织聚集在一起作为联盟形成网络，它们的权限由最初配置网络时联盟协商一致的一组策略决定。此外，网络策略可能会随着时间的推移而改变，这取决于联盟内部组织的一致同意，当讨论*修改策略*时，我们会发现这一点。\n示例网络 在开始前，向您展示我们的目标。这是表示我们示例网络最终状态的图。\n不必担心，这可能看起来很复杂！在阅读本篇文章的过程中，我们将一点一点地把网络建立起来，以便您了解组织 R1、R2、R3 和 R4 如何为网络贡献基础设施以帮助形成网络。该基础设施实现了区块链网络，并且被网络中的组织（例如，可以添加新组织的组织）一致同意的策略所管理。您将发现应用程序如何使用由区块链网络提供的账本和智能合约服务。\n 组织（Organization）：R1、R2、R3、R4  R1、R2、R3 和 R4 这四个组织共同决定并签署协议，它们将建立并利用 Hyperledger Fabric网络 。\nR4 被指定为网络的初始化者——它被授予创建网络最初版本的权力。R4 无意在网络中执行业务交易。\nR1 和 R2 以及 R2 和 R3 都需要在整个网络内进行隐私通信。\nR1 有一个客户端应用，通过通道 C1 执行业务交易。R2 也有一个客户端应用，通过 C1 和 C2 进行类似的工作。R3 有一个客户端应用，通过 C2 做相同的工作。\n Peer 节点：P1、P2、P3  P1 维护一个与 C1 连接的账本副本 L1。 P2 维护一个与 C1 连接的账本副本 L1 和与 C2 连接的账本副本 L2。P3 维护一个与 C2 连接的账本副本 L2。\n 通道（Channel）：C1、C2\n 账本（Ledger）：L1、L2\n 网络配置（Network Configuration）：NC4\n  本网络依赖网络配置 NC4 中指定的策略规则进行管理。本网络受 R1 和 R4 管理。\n 通道配置（Channel Configuration）：CC4  C1 依赖通道配置 CC1 中指定的策略规则进行管理。C1 受 R1 和 R2 管理。\nC2 依赖通道配置 CC2 中指定的策略规则进行管理。C2 受 R2 和 R3 管理。\n 排序服务（Ordering Service）：O4  有一个排序服务O4，作为N的网络管理节点，并使用系统通道。\n排序服务还支持应用程序通道 C1 和 C2，使交易排序打包进块里，为分发做准备。四个组织中每一个都有一个首选的证书颁发机构（Certificate Authority）。\n 颁发机构（Certificate Authority）：CA1、CA2、CA3、CA4  创建网络 让我们从创建网络的基础开始 ：\n启动排序者后便形成了网络。在我们的示例网络N中，由单个节点 O4 组成的排序服务根据网络配置 NC4 配置，NC4 授予 R4 管理权限。在网络层面，CA4 用于将身份分配给 R4 的管理员和网络节点。\n我们可以看到，排序服务 O4 首先定义了网络 N。将排序服务作为网络的最初管理节点很有用。按照事先约定，O4 最初由组织 R4 中的管理员配置和启动，并托管于 R4 中。配置 NC4 包含描述网络管理能力的最初集合的策略。最初，它设置只通过网络给 R4 权限。这将改变，正如我们后面将看到的，但是现在 R4 是网络的唯一成员。\n证书颁发机构（CA） 您还可以看到证书颁发机构 CA4，它用于向管理员和网络节点颁发证书。由于 CA4 分发 X.509 证书，所以它在我们的网络中有很重要的作用，该证书可以用来标示组件属于组织 R4。通过 CA 颁发的证书还可以用来签名交易，以表明组织认可交易结果——这是在账本上接受交易的先决条件。让我们更详细地研究 CA 的这两方面。\n首先，区块链网络的不同组件使用证书将自己标识为来自特定的组织。不同的组织通常使用不同的 CA。 Hyperledger Fabric 为您提供了一个内置的 CA（称为 Fabric-CA ）。但在实践中，组织将选择使用自己的 CA。\n证书到成员组织的映射是通过称为 Membership Services Provider (MSP) 的结构实现的。\n其次，稍后我们将看到CA颁发的证书如何成为交易生成和验证过程的核心。具体而言，X.509 证书用于客户端应用程序交易预案和智能合约交易响应中以进行数字签名交易。随后，托管账本副本的网络节点在接受交易到账本之前会验证交易签名是否有效。\n让我们回顾一下示例区块链网络的基本结构。网络 N 中的资源由证书颁发机构 CA4 定义的一组用户访问，这些用户对网络 N 中的资源具有一组权限，如网络配置 NC4 中包含的策略所述。当我们配置并启动订购服务节点 O4 时，所有这些都变为现实。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html\n","id":9,"section":"posts","summary":"区块链 这篇文章将在概念层面讲述 Hyperledger Fabric 如何允许组织在形成区块链网络方面进行协作。如果您是架构师、管理员或开发者，则可以利用本篇文章深入了解 Hyperledger Fabric 区","tags":["Hyperledger","Fabric"],"title":"Hyperledger Fabric 1.4 官方文档翻译之一：Key Concepts - Blockchain network (1)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%B8%80key-concepts-blockchain-network-1/","year":"2019"}],"tags":[{"title":"Fabric","uri":"https://devjue.github.io/tags/fabric/"},{"title":"git","uri":"https://devjue.github.io/tags/git/"},{"title":"hugo","uri":"https://devjue.github.io/tags/hugo/"},{"title":"Hyperledger","uri":"https://devjue.github.io/tags/hyperledger/"},{"title":"nginx","uri":"https://devjue.github.io/tags/nginx/"}]}