{"categories":[{"title":"web","uri":"https://devjue.github.io/categories/web/"},{"title":"区块链","uri":"https://devjue.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"posts":[{"content":" Commercial Papers 是 Fabric-Samples v1.4.4 中的重要示例。本文将只关注于 Commercial Paper，更多关于 Hyperledger Fabric 及 Fabric-Samples 的环境安装请查看Hyperledger Fabric 环境安装。另外，此示例支持 Javascript 和 Java 两种语言，我们只使用 Javascript 进行解析。\n场景 在 Commercial Papers 示例中，MagnetoCorp 是商业票据的发行商，DigiBank 是认购商业票据的投资银行。Isabella 和 Balaji 分别是这两家公司的员工，他们负责具体执行。\n启动区块链网络 以 网络管理员 身份，打开终端（称之为 终端1），运行 ./roles/network-starter.sh。该脚本将启动区块链网络，并监听其所有容器。其实，它是调用 ../basic-network 目录下的 teardown.sh 和 start.sh 完成启动的。下面是其逻辑伪代码：\n./roles/network-starter.sh 停止 docker 中的容器 cliDigiBank、cliMagnetoCorp、logspout # 调用 ../basic-network/teardown.sh 停止 docker 中的其它容器 删除所有 dev-* 镜像 # 调用 ../basic-network/start.sh 启动 ca、order、peer、couchdb 四个容器 创建名为 mychannel 的通道 把 peer0.org1.example.com 加入通道 mychannel # 调用 ./organization/magnetocorp/configuration/cli/monitordocker.sh 监听该网络上的所有容器，并将日志打印到终端  执行该脚本。如果成功启动，会看到如下结果：\n$ bash roles/network-starter.sh ... docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 92adc82fcb8a hyperledger/fabric-peer \u0026quot;peer node start\u0026quot; 1 second ago Up Less than a second 0.0.0.0:7051-\u0026gt;7051/tcp, 0.0.0.0:7053-\u0026gt;7053/tcp peer0.org1.example.com cfa4d04f20ce hyperledger/fabric-couchdb \u0026quot;tini -- /docker-ent…\u0026quot; 2 seconds ago Up Less than a second 4369/tcp, 9100/tcp, 0.0.0.0:5984-\u0026gt;5984/tcp couchdb adddc8066dae hyperledger/fabric-ca \u0026quot;sh -c 'fabric-ca-se…\u0026quot; 2 seconds ago Up Less than a second 0.0.0.0:7054-\u0026gt;7054/tcp ca.example.com ca43d55e87eb hyperledger/fabric-orderer \u0026quot;orderer\u0026quot; 2 seconds ago Up Less than a second 0.0.0.0:7050-\u0026gt;7050/tcp orderer.example.com ... # ------------------------------------------------------------------------------- # # Good to start the applications in other terminals # \u0026quot;${DIR}/organization/magnetocorp/configuration/cli/monitordocker.sh\u0026quot; net_basic Starting monitoring on all containers on the network net_basic ... peer0.org1.example.com|... [gossip.election] beLeader -\u0026gt; INFO 038 3d61f17d60ad28cbef5193bf66a12717007545d938788b9878df1d091773ee06 : Becoming a leader peer0.org1.example.com|... [gossip.service] func1 -\u0026gt; INFO 039 Elected as a leader, starting delivery service for channel mychannel peer0.org1.example.com|... [deliveryClient] StartDeliverForChannel -\u0026gt; INFO 03a This peer will retrieve blocks from ordering service and disseminate to other peers in the organization for channel mychannel peer0.org1.example.com|... [deliveryClient] RequestBlocks -\u0026gt; INFO 03b Starting deliver with block [1] for channel mychannel  安装并实例化智能合约 以 Isabella（MagnetoCorp 的员工）的身份，再打开一个终端（称之为 终端2），运行 ./roles/magnetocorp.sh。该脚本将启动 docker 容器 cliMagnetoCorp，并提示您如何安装并实例化智能合约 papercontract。\n$ bash roles/magentocorp.sh Creating cliMagnetoCorp ... done ...  安装智能合约 $ docker exec cliMagnetoCorp peer chaincode install -n papercontract -v 0 -p /opt/gopath/src/github.com/contract -l node ... [chaincodeCmd] checkChaincodeCmdParams -\u0026gt; INFO 001 Using default escc ... [chaincodeCmd] checkChaincodeCmdParams -\u0026gt; INFO 002 Using default vscc ... [chaincodeCmd] install -\u0026gt; INFO 003 Installed remotely response:\u0026lt;status:200 payload:\u0026quot;OK\u0026quot; \u0026gt;  如果安装成功，终端1 也会看到如下日志：\npeer0.org1.example.com|... [lscc] executeInstall -\u0026gt; INFO 03e Installed Chaincode [papercontract] Version [0] to peer  实例化智能合约 $ docker exec cliMagnetoCorp peer chaincode instantiate -n papercontract -v 0 -l node -c '{\u0026quot;Args\u0026quot;:[\u0026quot;org.papernet.commercialpaper:instantiate\u0026quot;]}' -C mychannel -P \u0026quot;AND ('Org1MSP.member')\u0026quot; 2019-12-31 11:53:41.570 [chaincodeCmd] InitCmdFactory -\u0026gt; INFO 001 Retrieved channel (mychannel) orderer endpoint: orderer.example.com:7050 2019-12-31 11:53:41.572 [chaincodeCmd] checkChaincodeCmdParams -\u0026gt; INFO 002 Using default escc 2019-12-31 11:53:41.572 [chaincodeCmd] checkChaincodeCmdParams -\u0026gt; INFO 003 Using default vscc  如果成功，docker 会启动一个新的 dev-peer0.org1.example.com-papercontract-0 容器。\n发行 继续以 Isabella 的身份，在 终端2 中，进入目录 ./organization/magnetocorp/application/。先安装依赖，然后将身份证书加入 magnetocorp 的钱包，并发行商业票据。\n安装依赖 $ cd organization/magnetocorp/application/ $ npm install  将身份证书加入钱包 $ node addToWallet.js done  发行商业票据 $ node issue.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper issue transaction. Process issue transaction response.{\u0026quot;class\u0026quot;:\u0026quot;org.papernet.commercialpaper\u0026quot;,\u0026quot;key\u0026quot;:\u0026quot;\\\u0026quot;MagnetoCorp\\\u0026quot;:\\\u0026quot;00001\\\u0026quot;\u0026quot;,\u0026quot;currentState\u0026quot;:1,\u0026quot;issuer\u0026quot;:\u0026quot;MagnetoCorp\u0026quot;,\u0026quot;paperNumber\u0026quot;:\u0026quot;00001\u0026quot;,\u0026quot;issueDateTime\u0026quot;:\u0026quot;2020-05-31\u0026quot;,\u0026quot;maturityDateTime\u0026quot;:\u0026quot;2020-11-30\u0026quot;,\u0026quot;faceValue\u0026quot;:\u0026quot;5000000\u0026quot;,\u0026quot;owner\u0026quot;:\u0026quot;MagnetoCorp\u0026quot;} MagnetoCorp commercial paper : 00001 successfully issued for value 5000000 Transaction complete. Disconnect from Fabric gateway. Issue program complete.  如果运行成功，在 终端1 中会看到：\n... peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 04b [mychannel][fe9e3531] Entry chaincode: name:\u0026quot;cscc\u0026quot; peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 04c [mychannel][fe9e3531] Exit chaincode: name:\u0026quot;cscc\u0026quot; (8ms) peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 04d unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=172.23.0.1:38040 grpc.code=OK grpc.call_duration=9.010866ms peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 04e [mychannel][294763f2] Entry chaincode: name:\u0026quot;papercontract\u0026quot; peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 04f [mychannel][294763f2] Exit chaincode: name:\u0026quot;papercontract\u0026quot; (9ms) peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 050 unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=172.23.0.1:38040 grpc.code=OK grpc.call_duration=9.491494ms dev-peer0.org1.example.com-papercontract-0|...Z info [shim:lib/handler.js] [mychannel-294763f2] Calling chaincode Invoke() succeeded. Sending COMPLETED message back to peer orderer.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 00f streaming call completed grpc.service=orderer.AtomicBroadcast grpc.method=Broadcast grpc.peer_address=172.23.0.1:49944 grpc.code=OK grpc.call_duration=8.056409ms peer0.org1.example.com|... [gossip.privdata] StoreBlock -\u0026gt; INFO 051 [mychannel] Received block [2] from buffer peer0.org1.example.com|... [committer.txvalidator] Validate -\u0026gt; INFO 052 [mychannel] Validated block [2] in 0ms couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; 0a19b37ca8 couchdb:5984 172.23.0.5 undefined POST /mychannel_lscc/_all_docs?include_docs=true 200 ok 1 couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; 6b4c575892 couchdb:5984 172.23.0.5 undefined GET /mychannel_papercontract 404 ok 0 couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; 2d402a123d couchdb:5984 172.23.0.5 undefined PUT /mychannel_papercontract 201 ok 31 couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; e6d95be5bc couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_all_docs?include_docs=true 200 ok 1 peer0.org1.example.com|... [couchdb] CreateDatabaseIfNotExist -\u0026gt; INFO 053 Created state database mychannel_papercontract couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; 4e511717bd couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_bulk_docs 201 ok 6 couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; 871b91f448 couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_ensure_full_commit 201 ok 0 couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; d734f253ca couchdb:5984 172.23.0.5 undefined GET /mychannel_/statedb_savepoint?attachments=true 200 ok 1 couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; 5951cf8257 couchdb:5984 172.23.0.5 undefined GET /mychannel_papercontract/_index 200 ok 1 couchdb|[notice] ... nonode@nohost \u0026lt;0.14905.0\u0026gt; 99e486983f couchdb:5984 172.23.0.5 undefined PUT /mychannel_/statedb_savepoint 201 ok 3 peer0.org1.example.com|... [kvledger] CommitWithPvtData -\u0026gt; INFO 054 [mychannel] Committed block [2] with 1 transaction(s) in 70ms (state_validation=3ms block_and_pvtdata_commit=10ms state_commit=48ms) commitHash=[050857e4d2fc3095412fe72d7a6abe580418a09d99daddc053d35b18216c392c] peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 055 streaming call completed grpc.service=protos.Deliver grpc.method=Deliver grpc.peer_address=172.23.0.1:38040 error=\u0026quot;context finished before block retrieved: context canceled\u0026quot; grpc.code=Unknown grpc.call_duration=2.097318084s ...  认购 现在，以 Balaji（DigiBank 的员工） 的身份，再打开一个终端（称之为 终端3），运行 ./roles/digibank.sh。该脚本将启动 docker 容器 cliDigiBank。因为之前已经安装并实例化了智能合约 papercontract，所以无需再做相同的工作。\n$ bash roles/digibank.sh Creating cliDigiBank ... done ...  跟 Isabella 一样，在认购之前，需要先安装依赖，并将 Balaji 的身份证书加入其钱包。\n安装依赖 $ cd organization/digibank/application $ npm install  将身份证书加入钱包 $ node addToWallet.js done  认购商业票据 $ node buy.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper buy transaction. Process buy transaction response. MagnetoCorp commercial paper : 00001 successfully purchased by DigiBank Transaction complete. Disconnect from Fabric gateway. Buy program complete.  如果运行成功，在 终端1 中会看到：\npeer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 056 [mychannel][6b7ae889] Entry chaincode: name:\u0026quot;cscc\u0026quot; peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 057 [mychannel][6b7ae889] Exit chaincode: name:\u0026quot;cscc\u0026quot; (0ms) peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 058 unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=172.23.0.1:39574 grpc.code=OK grpc.call_duration=855.36µs peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 059 [mychannel][4f21a45f] Entry chaincode: name:\u0026quot;papercontract\u0026quot; dev-peer0.org1.example.com-papercontract-0|... info [shim:lib/handler.js] [mychannel-4f21a45f] Calling chaincode Invoke() succeeded. Sending COMPLETED message back to peer peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 05a [mychannel][4f21a45f] Exit chaincode: name:\u0026quot;papercontract\u0026quot; (9ms) couchdb|[notice] ... nonode@nohost \u0026lt;0.11233.1\u0026gt; def4e6d36a couchdb:5984 172.23.0.5 undefined GET /mychannel_papercontract/%00org.papernet.commercialpaperlist%00%22MagnetoCorp%22%00%2200001%22%00?attachments=true 200 ok 1 peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 05b unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=172.23.0.1:39574 grpc.code=OK grpc.call_duration=9.728807ms orderer.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 010 streaming call completed grpc.service=orderer.AtomicBroadcast grpc.method=Broadcast grpc.peer_address=172.23.0.1:51480 grpc.code=OK grpc.call_duration=7.694869ms peer0.org1.example.com|... [gossip.privdata] StoreBlock -\u0026gt; INFO 05c [mychannel] Received block [3] from buffer peer0.org1.example.com|... [committer.txvalidator] Validate -\u0026gt; INFO 05d [mychannel] Validated block [3] in 0ms couchdb|[notice] ... nonode@nohost \u0026lt;0.11233.1\u0026gt; 417ff170d9 couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_all_docs?include_docs=true 200 ok 3 couchdb|[notice] ... nonode@nohost \u0026lt;0.11233.1\u0026gt; 951bd509b6 couchdb:5984 172.23.0.5 undefined POST /mychannel_lscc/_all_docs?include_docs=true 200 ok 4 couchdb|[notice] ... nonode@nohost \u0026lt;0.11233.1\u0026gt; 5d7af52cd2 couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_bulk_docs 201 ok 3 couchdb|[notice] ... nonode@nohost \u0026lt;0.11233.1\u0026gt; ec72c4a592 couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_ensure_full_commit 201 ok 0 couchdb|[notice] ... nonode@nohost \u0026lt;0.11233.1\u0026gt; 88579d0d42 couchdb:5984 172.23.0.5 undefined GET /mychannel_/statedb_savepoint?attachments=true 200 ok 1 couchdb|[notice] ... nonode@nohost \u0026lt;0.11270.1\u0026gt; b77b909e01 couchdb:5984 172.23.0.5 undefined GET /mychannel_papercontract/_index 200 ok 2 couchdb|[notice] ... nonode@nohost \u0026lt;0.11233.1\u0026gt; e8a7d51b5b couchdb:5984 172.23.0.5 undefined PUT /mychannel_/statedb_savepoint 201 ok 4 peer0.org1.example.com|... [kvledger] CommitWithPvtData -\u0026gt; INFO 05e [mychannel] Committed block [3] with 1 transaction(s) in 34ms (state_validation=9ms block_and_pvtdata_commit=11ms state_commit=10ms) commitHash=[04a6ddd78a532d6dbe4f09d77e4ad7e1d9afcb414a4cf5ac804febeff3a23e94] peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 05f streaming call completed grpc.service=protos.Deliver grpc.method=Deliver grpc.peer_address=172.23.0.1:39574 error=\u0026quot;context finished before block retrieved: context canceled\u0026quot; grpc.code=Unknown grpc.call_duration=2.055971041s  赎回 继续以 Balaji 的身份，在 终端3 中，执行 node redeem.js。\n$ node redeem.js Connect to Fabric gateway. Use network channel: mychannel. Use org.papernet.commercialpaper smart contract. Submit commercial paper redeem transaction. Process redeem transaction response. MagnetoCorp commercial paper : 00001 successfully redeemed with MagnetoCorp Transaction complete. Disconnect from Fabric gateway. Redeem program complete.  如果运行成功，在 终端1 中会看到：\npeer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 060 [mychannel][be94012c] Entry chaincode: name:\u0026quot;cscc\u0026quot; peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 061 [mychannel][be94012c] Exit chaincode: name:\u0026quot;cscc\u0026quot; (0ms) peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 062 unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=172.23.0.1:40102 grpc.code=OK grpc.call_duration=811.699µs peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 063 [mychannel][37e6d5cd] Entry chaincode: name:\u0026quot;papercontract\u0026quot; dev-peer0.org1.example.com-papercontract-0|... info [shim:lib/handler.js] [mychannel-37e6d5cd] Calling chaincode Invoke() succeeded. Sending COMPLETED message back to peer peer0.org1.example.com|... [endorser] callChaincode -\u0026gt; INFO 064 [mychannel][37e6d5cd] Exit chaincode: name:\u0026quot;papercontract\u0026quot; (10ms) couchdb|[notice] ... peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 065 unary call completed grpc.service=protos.Endorser grpc.method=ProcessProposal grpc.peer_address=172.23.0.1:40102 grpc.code=OK grpc.call_duration=10.884385ms orderer.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 011 streaming call completed grpc.service=orderer.AtomicBroadcast grpc.method=Broadcast grpc.peer_address=172.23.0.1:52008 grpc.code=OK grpc.call_duration=7.770788ms peer0.org1.example.com|... [gossip.privdata] StoreBlock -\u0026gt; INFO 066 [mychannel] Received block [4] from buffer peer0.org1.example.com|... [committer.txvalidator] Validate -\u0026gt; INFO 067 [mychannel] Validated block [4] in 0ms couchdb|[notice] ... nonode@nohost \u0026lt;0.21017.1\u0026gt; c8a28d069e couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_all_docs?include_docs=true 200 ok 6 couchdb|[notice] ... nonode@nohost \u0026lt;0.21017.1\u0026gt; 3834a1b72c couchdb:5984 172.23.0.5 undefined POST /mychannel_lscc/_all_docs?include_docs=true 200 ok 6 couchdb|[notice] ... nonode@nohost \u0026lt;0.21017.1\u0026gt; 578febab18 couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_bulk_docs 201 ok 3 couchdb|[notice] ... nonode@nohost \u0026lt;0.21017.1\u0026gt; 5b1f1836b7 couchdb:5984 172.23.0.5 undefined POST /mychannel_papercontract/_ensure_full_commit 201 ok 0 couchdb|[notice] ... nonode@nohost \u0026lt;0.21057.1\u0026gt; d80d22a615 couchdb:5984 172.23.0.5 undefined GET /mychannel_papercontract/_index 200 ok 1 couchdb|[notice] ... nonode@nohost \u0026lt;0.21017.1\u0026gt; 9c9835183f couchdb:5984 172.23.0.5 undefined GET /mychannel_/statedb_savepoint?attachments=true 200 ok 4 couchdb|[notice] ... nonode@nohost \u0026lt;0.21017.1\u0026gt; b50e39a2d4 couchdb:5984 172.23.0.5 undefined PUT /mychannel_/statedb_savepoint 201 ok 6 peer0.org1.example.com|... [kvledger] CommitWithPvtData -\u0026gt; INFO 068 [mychannel] Committed block [4] with 1 transaction(s) in 41ms (state_validation=13ms block_and_pvtdata_commit=10ms state_commit=14ms) commitHash=[9370bdbae339b1be98d289a0674b705091d72628a789e9a0696d28b16ebc7a34] peer0.org1.example.com|... [comm.grpc.server] 1 -\u0026gt; INFO 069 streaming call completed grpc.service=protos.Deliver grpc.method=Deliver grpc.peer_address=172.23.0.1:40102 error=\u0026quot;context finished before block retrieved: context canceled\u0026quot; grpc.code=Unknown grpc.call_duration=2.061375712s  参考 https://github.com/hyperledger/fabric-samples/tree/v1.4.4/commercial-paper\n","id":0,"section":"posts","summary":"Commercial Papers 是 Fabric-Samples v1.4.4 中的重要示例。本文将只关注于 Commercial Paper，更多关于 Hyperledger Fabric 及 Fabric-Samples 的环境安装请查看Hyperledger Fabric 环境安装。另外，此示例支持 Javascript 和 Java","tags":["Hyperledger","Fabric"],"title":"Commercial Paper 解析","uri":"https://devjue.github.io/2019/12/commercial-paper-%E8%A7%A3%E6%9E%90/","year":"2019"},{"content":" Peer 和 Orderer 我们已经看到 peer 构成了区块链网络的基础，托管了账本和智能合约，它们可以被与 peer 连接的应用程序查询和更新。但是，应用程序和 peer 进行交互来确保每个 peer 的账本保持一致性的机制，由被称为 orderer 的特殊节点协调，现在我们把注意力转移到这些节点上。\n更新交易与查询交易完全不同，因为单个 peer 自身无法更新账本——更新需要网络中的其它 peer 批准。peer 需要网络中的其它 peer 批准账本更新，然后才能将其应用于 peer 的本地账本。这个过程称为 *共识*，比简单查询需要更长时间才能完成。但是当所有需要批准交易的 peer 都批准了该交易并将交易已经提交给账本时，peer 将通知它们连接的应用程序，账本已经被更新。在本节中，您将了解更多有关 peer 和 orderer 如何管理共识过程的细节。\n具体来讲，想要更新账本的应用程序涉及三个阶段的过程，这些过程确保了区块链网络中的所有 peer 保持其账本彼此一致。在第一阶段，应用程序与一组背书节点一起工作，每个背书节点都向应用程序提供提交预案的账本更新的背书，但是不将提交预案的更新应用在其账本副本上。在第二阶段，这些独立背书汇集在一起作为交易并被打包进区块。在最后一个阶段，这些区块被分发回每个 peer，每笔交易被验证后，再应用于 peer 的账本副本。\n正如您所见，orderer 节点是这个过程的核心，所以让我们对应用程序和 peer 如何使用 orderer 生成可以一致性地应用于分布式的自我复制的账本的账本更新进一步研究。\n第一阶段：提案 交易工作流的第一阶段涉及应用程序和一组 peer（不包括 orderer）之间的交互。第一阶段只与请求不同组织的背书节点同意提交预案的链码调用结果的应用程序有关。\n第一阶段开始，应用程序生成交易预案，并将其发送至每个需要的 peer 组，以便背书。然后，这些 背书节点 的每一个都独立执行链码，使用交易预案生成交易预案应答。它不将这个更新应用于账本，只是简单地对它签名并将它返回给应用程序。应用程序一旦收到足够数量的签名预案应答，交易流的第一阶段就完成了。让我们更详细地研究这个阶段。\n交易预案被返回背书预案应答的 peer 独立执行。在这个示例中，应用程序 A1 生成交易 T1 的预案 P，并将它发送给通道 C 上的 peer P1 和 peer P2。P1 执行 S1，使用交易 T1 的预案 P 生成交易 T1 的应答 R1，并用 E1 为 R1 背书。独立地，P2 执行 S2，使用交易 T1 的预案 P 生成交易 T1 的应答 R2，并用 E2 为 R2 背书。应用程序 A1 收到两个交易 T1 的背书应答，即 E1 和 E2。\n最初，一组 peer 被应用程序选择用来生成一组提交预案的账本更新。哪些 peer 会被应用程序选中？这取决于（为链码定义的）*背书策略*，它定义了一组在提交预案的账本更新被网络接受前，需要对其进行背书的组织。在字面意思上，这意味着达成共识——每个相关组织必须在提交预案的账本更新被任何 peer 账本接受前对其进行背书。\npeer 通过添加其数字签名并使用其私钥对整个 payload 进行签名来背书预案应答。该背书可以随后被用来证明这个组织的节点生成了特定的应答。在我们的示例中，如果 peer P1 属于组织 Org1，背书 E1 相当于数字证明“账本 L1 上的交易 T1 的应答 R1 是由 Org1 的 peer P1 提供的。”\n第一阶段的最后，当应用程序收到足够数量的 peer 的签名预案应答时。我们注意，不同的 peer 可以返回不同的应答，因此，对于应用程序，对 同样的交易预案 存在不一致的交易应答。这可能只是在不同时间，由拥有不同状态账本的不同 peer 生成的结果，在这种情况下，应用程序可以简单地请求更多的最新预案应答。较少的，但更严重的情况是，结果不同是因为链码的不确定性。不确定性是链码和账本的敌人，如果这发生了，则表示预案交易存在非常严重的问题，因为显然不能将不一致的结果应用于账本。一个独立的 peer 不会知道它们的交易结果是不确定的——交易应答必须汇集在一起进行比较，然后才能发现不确定。（严格地讲，这还不够，但我们把这个讨论推迟到交易部分，在那个部分将详细讨论不确定性。）\n在第一阶段的结束时，应用程序可以随意丢弃不一致的交易应答，从而有效地尽早终止交易工作流。我们稍后将看到，如果应用程序尝试使用一组不一致的交易应答来更新账本，它将被拒绝。\n第二阶段：把交易排序和打包进区块 交易工作流的第二阶段是打包阶段。orderer 是这个过程的核心——它从很多应用程序接收包含背书交易预案应答的交易，并将其排序进区块。有关排序和打包阶段的更多详细信息，请查看我们的排序阶段概念。\n第三阶段：验证和提交 在第二阶段的结束，我们看到 orderer 负责简单但至关重要的过程，包括收集提交预案的账本更新，对其进行排序并打包进区块中，为将其分发至 peer 做好准备。\n交易工作流的最后阶段涉及分发并随后验证区块，这些区块从 orderer 到 peer，并能够应用于 peer 上的账本。具体来讲，在每个 peer 上，每笔拥有区块的交易都在其应用于账本前，被验证以确保它是被所有相关组织一致性背书的。失败的交易被保留用于审计，但不应用于账本。\norderer 节点的第二个作用是把区块分发给 peer。在这个示例中，orderer O1 把区块 B2 分发给 peer P1 和 peer P2。Peer P1 处理区块 B2，使得一个新的区块被添加到 P1 上的账本 L1 中。并行的，peer P2 处理区块 B2，使得一个新的区块被添加到 P2上的账本 L1 中。该过程一旦完成，账本 L1 就已经在 peer P1 和 P2 上被一致性地更新了。P1 和 P2 将通知与之相连的应用程序，该交易已处理。\n第三阶段从 orderer 把区块分发给所有与之相连的 peer 开始。peer 通过通道与 orderer 相连，以便当新的区块生成后，所有与 orderer 相连的 peer 都将被发送新区块的副本。每个 peer 将独立处理该区块，但方法与通道上的每个其它 peer 完全一样。这样，我们将看到账本能够保持一致。还值得注意的是，并非每个 peer 都需要连接到 orderer——peer 使用 gossip 协议级联区块到其它 peer，后者可以独立处理它们。但是，让我们将这个讨论留在其它时间进行。\n收到区块后，peer 将按照出现在区块中的顺序处理每笔交易。对于每笔交易，每个 peer 都将依据生成该交易的链码的 *背书策略*，验证交易是否已被所需组织背书过。例如，某些交易可能只需要单个组织进行背书，然而其它交易可能需要多个背书才能被视为有效。这个验证过程验证所有相关组织均已产生相同的结果。还需要注意，这个验证不同于第一阶段的背书检查，在第一阶段中，应用程序是从背书节点接收应答并做出发送预案交易的决定。如果应用程序通过发送错误交易违反了背书策略，peer 仍然可以在第三阶段的验证过程中拒绝该交易。\n如果交易已经被正确地背书，peer 将尝试将其应用于账本。为此，peer 必须执行账本一致性检查，以验证账本的当前状态与生成提交预案的更新时的账本状态相兼容。即使交易已经完全背书，这也不总是可能的。例如，另一个交易可能已经更新了账本中的同一资产，以致交易更新将不再有效，因此其不能再被应用。这样，每个 peer 的账本副本都在网络中保持一致，因为它们每个都遵循相同的验证规则。\npeer 成功验证每个独立交易后，它将更新账本。失败的交易不应用于账本，但它们被保留以供审计，像成功的交易一样。这意味着 peer 区块几乎与从 orderer 接收的区块完全相同，除了该区块中每个交易有效或无效的标志。\n我们还要注意，第三阶段不需要运行链码——其仅在第一阶段完成，这很重要。这意味着链码链码只在背书节点上可用，而不是在整个区块链网络上可用。这通常很有用，因为它可以使链码逻辑对背书组织保密。这与链码的输出（交易预案应答）相反，链码的输出与通道中的每个 peer 共享，不论该 peer 是否背书交易。设计背书节点的这个特点有助于增强可扩展性。\n最后，每次将区块提交给 peer 的账本时，peer 都生成一个适当的 *事件*。区块事件 包含全部区块内容，而 区块交易事件 仅包含摘要信息，例如区块中的每笔交易是否已验证或无效的。链码执行产生的 链码事件 也可以此时发布出来。应用可以注册这些事件类型，以便在事件发生时得到通知。这些通知结束了交易工作流的第三阶段，也是最后阶段。\n总之，第三阶段看到了由 orderer 生成的区块一致性地应用于账本。将交易严格地排序进区块，允许每个 peer 验证该交易更新是否在整个区块链网络中得到一致性地应用。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/peers/peers.html\n","id":1,"section":"posts","summary":"Peer 和 Orderer 我们已经看到 peer 构成了区块链网络的基础，托管了账本和智能合约，它们可以被与 peer 连接的应用程序查询和更新。但是，应用程序和 peer 进行交互来确保每","tags":["Hyperledger","Fabric","翻译"],"title":"Hyperledger Fabric 1.4 官方文档翻译之八：Key Concepts - Peers - Peers and Orderers","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E5%85%ABkey-concepts-peers-peers-and-orderers/","year":"2019"},{"content":" first-network 是 hyperledger/fabric-samples 项目的一个区块链示例。该示例向我们展示了一个简单的区块链，以及如何在区块链网络上安装、实例化、查询、调用链码。\n常用命令 first-network 提供了一个脚本 byfn.sh，供测试使用。其中，常用的命令有以下三个：\n byfn.sh generate   生成 first-network 需要的所有证书、创世区块和三个配置交易。即本文“准备工作”一节的全部内容。一般地，先执行 byfn.sh generate，再执行 byfn.sh up。\n byfn.sh up   启动 first-network，并完成 end-to-end 测试。注意，在启动 first-network 之前，byfn.sh up 会检测目录 crypto-config/ 是否存在，该目录是由 byfn.sh generate 生成的，以此判断是否执行过 byfn.sh generate。如果该目录不存在，会先执行与 byfn.sh generate 等效的所有操作，即本文“准备工作”一节的全部内容。\n所以，其实不先执行 byfn.sh generate，也可以直接执行 byfn.sh up。本文将采用此做法。\n byfn.sh down   停止 first-network，删除所有 docker 容器、证书、创世区块和三个配置交易，删除由 byfn.sh up 生成的链码镜像。\nbyfn.sh up 直接执行 byfn.sh up。\n$ byfn.sh up  准备工作 生成证书 使用 cryptogen，依据 crypto-config.yaml 生成证书。\n# byfn.sh # - networkUp # - generateCerts cryptogen generate --config=./crypto-config.yaml  调用 ./ccp-generate.sh 脚本，为 org1 和 org2 生成 ccp 文件。\n connection-org1.json connection-org1.yaml connection-org2.json connection-org2.yaml  替换私钥 拷贝生成 docker-compose-e2e.yaml 配置文件，并替换 CA1_PRIVATE_KEY、CA2_PRIVATE_KEY。\n# byfn.sh # - networkUp # - replacePrivateKey cp docker-compose-e2e-template.yaml docker-compose-e2e.yaml sed $OPTS \u0026quot;s/CA1_PRIVATE_KEY/${PRIV_KEY}/g\u0026quot; docker-compose-e2e.yaml sed $OPTS \u0026quot;s/CA2_PRIVATE_KEY/${PRIV_KEY}/g\u0026quot; docker-compose-e2e.yaml  生成 artifacts 使用 cryptogen，依据 configtx.yaml 在目录 ./channel-artifacts 下生成 *genesis.block*、*channel.tx*、Org1MSPanchors.tx 和 *Org2MSPanchors.tx*。\n# byfn.sh # - networkUp # - generateChannelArtifacts # 生成创世区块 genesis.block configtxgen -profile TwoOrgsOrdererGenesis -channelID $SYS_CHANNEL -outputBlock ./channel-artifacts/genesis.block # 生成 channel.tx configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID $CHANNEL_NAME # 生成 Org1MSPanchors.tx configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP # 生成 Org2MSPanchors.tx configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP  初始化容器 使用 docker-compose 加载容器。\n# byfn.sh # - networkUp IMAGE_TAG=$IMAGETAG docker-compose ${COMPOSE_FILES} up -d 2\u0026gt;\u0026amp;1  以下容器运行成功。\nIMAGE COMMAND NAMES hyperledger/fabric-tools:latest \u0026quot;/bin/bash\u0026quot; cli hyperledger/fabric-peer:latest \u0026quot;peer node start\u0026quot; peer0.org2.example.com hyperledger/fabric-orderer:latest \u0026quot;orderer\u0026quot; orderer.example.com hyperledger/fabric-peer:latest \u0026quot;peer node start\u0026quot; peer0.org1.example.com hyperledger/fabric-peer:latest \u0026quot;peer node start\u0026quot; peer1.org2.example.com hyperledger/fabric-peer:latest \u0026quot;peer node start\u0026quot; peer1.org1.example.com  初始化网络 调用 scripts/script.sh，完成 end-to-end 测试。\n ____ _____ _ ____ _____ / ___| |_ _| / \\ | _ \\ |_ _| \\___ \\ | | / _ \\ | |_) | | | ___) | | | / ___ \\ | _ \u0026lt; | | |____/ |_| /_/ \\_\\ |_| \\_\\ |_| Build your first network (BYFN) end-to-end test ...  引用 scripts/utils.sh。\n# scripts/script.sh . scripts/utils.sh  创建 channel 使用 peer channel create，依据 *channel.tx*，创建 channel。\n# scripts/script.sh # - createChannel docker exec cli peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA  加入 channel 循环调用 joinChannelWithRetry [scripts/utils.sh]，使用 peer channel join，把 peer0.org1、peer1.org1、peer0.org2 和 peer1.org2 加入 channel。\n# scripts/script.sh # - joinChannel # - joinChannelWithRetry [scripts/utils.sh] peer channel join -b $CHANNEL_NAME.block  更新 anchor peer 使用 peer channel update，依据 Org1MSPanchors.tx 和 *Org1MSPanchors.tx*，分别更新 peer0.org1 为 org1 的 auchor peer，peer0.org2 为 org2 的 auchor peer。\n# scripts/utils.sh # - updateAnchorPeers docker exec cli peer channel update -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/${CORE_PEER_LOCALMSPID}anchors.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA  安装链码 使用 peer chaincode install，将链码 chaincode_example02 安装到 peer0.org1 和 peer0.org2 上。\n# scripts/utils.sh # - installChaincode docker exec cli peer chaincode install -n mycc -v ${VERSION} -l ${LANGUAGE} -p ${CC_SRC_PATH}  实例化链码 使用 peer chaincode instantiate，在 peer0.org2 上实例化链码 *chaincode_example02*。初始化账本上数据：{\u0026ldquo;a\u0026rdquo;:\u0026ldquo;100\u0026rdquo;,\u0026ldquo;b\u0026rdquo;:\u0026ldquo;200\u0026rdquo;}。规定背书策略：任何交易必须要有 org1 和 org2 节点的同时背书。\n# scripts/utils.sh # - instantiateChaincode docker exec cli peer chaincode instantiate -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -l ${LANGUAGE} -v 1.0 -c '{\u0026quot;Args\u0026quot;:[\u0026quot;init\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;100\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;200\u0026quot;]}' -P \u0026quot;AND ('Org1MSP.peer','Org2MSP.peer')\u0026quot;  查询链码 使用 peer chaincode query，在 peer0.org1 上查询 a 的值是 100。注意，之前是在 peer0.org2 上实例化的链码，现在 peer0.org1 上查询 a 成功，说明账本已经跨组织完成同步。\n# scripts/utils.sh # - chaincodeQuery docker exec cli peer chaincode query -C $CHANNEL_NAME -n mycc -c '{\u0026quot;Args\u0026quot;:[\u0026quot;query\u0026quot;,\u0026quot;a\u0026quot;]}'  调用链码 使用 peer chaincode invoke，在 peer0.org1 和 peer0.org2 上调用链码，实现 a 向 b 转让 10，即 a 减少10，b 增加 10。注意，之前在实例化链码时规定的背书策略是，任何交易必须要有 org1 和 org2 节点的同时背书，该调用符合此背书策略，所以交易可以成功。\n# scripts/utils.sh # - chaincodeInvoke docker exec cli peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc $PEER_CONN_PARMS -c '{\u0026quot;Args\u0026quot;:[\u0026quot;invoke\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;10\u0026quot;]}'  安装链码 使用 peer chaincode install，将链码 chaincode_example02 安装到 peer1.org2 上。该操作是为下一步在 peer1.org2 上使用链码做准备。peer 想要使用链码，必须预先安装链码。\n# scripts/utils.sh # - installChaincode docker exec cli peer chaincode install -n mycc -v ${VERSION} -l ${LANGUAGE} -p ${CC_SRC_PATH}  查询链码 使用 peer chaincode query，在 peer1.org2 上查询 a 的值是 90，说明账本同步成功。\n# scripts/utils.sh # - chaincodeQuery docker exec cli peer chaincode query -C $CHANNEL_NAME -n mycc -c '{\u0026quot;Args\u0026quot;:[\u0026quot;query\u0026quot;,\u0026quot;a\u0026quot;]}'  first-network 启动成功 ========= All GOOD, BYFN execution completed =========== _____ _ _ ____ | ____| | \\ | | | _ \\ | _| | \\| | | | | | | |___ | |\\ | | |_| | |_____| |_| \\_| |____/  参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/build_network.html\n","id":2,"section":"posts","summary":"first-network 是 hyperledger/fabric-samples 项目的一个区块链示例。该示例向我们展示了一个简单的区块链，以及如何在区块链网络上安装、实例化、查询、调用链码。 常用命令 first-network 提供了一个脚本","tags":["Hyperledger","Fabric","byfn.sh"],"title":"First-Network Byfn.sh 解析","uri":"https://devjue.github.io/2019/12/first-network-byfn.sh-%E8%A7%A3%E6%9E%90/","year":"2019"},{"content":" Hyperledger Fabric 需要 Docker、Golang、Node.js 和 Python2.7。Docker 容器用来启动 Fabric 的各个组件镜像。Go 是 Fabric 的开发语言，我们需要使用 Go 语言编写智能合约链码程序。Node.js 用来开发 Fabric 的应用程序，因为 Fabric 提供了 Node.js 版本的 SDK。Python2.7 用来完成 npm install 操作，这是 Fabric Node.js SDK 需要的。\n Docker 17.06.2-ce 以上版本  Docker Compose 1.14.0 以上版本  Go 1.12.x 版本 Node.js 10.15.3 以上版本 Python2.7  查看系统配置 本次安装的操作系统是 CentOS7.5，服务器是2核8G虚拟机。\n$ cat /etc/centos-release CentOS Linux release 7.5.1804 (Core) $ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 2 Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.50GHz  安装软件 首先，使用 root 账户为 Hyperledger Fabric 创建一个独立的用户 fabric，并授予其 sudo 权限。切换至 fabric 账户，初始化 fabric 的用户目录。接着，使用 sudo 安装一些基础库、Docker 和 Go。然后，在 fabric 用户目录下，使用源码安装 Python2.7 和 node.js，仅供 fabric 使用。最后，下载并安装 Hyperledger Fabric 和 Fabric Samples。\n创建用户 fabric 创建用户 fabric ，并初始化密码。\n$ adduser fabric $ passwd fabric Changing password for user fabric. New password: # 输入新密码 Retype new password: # 重复输入新密码  授予 fabric sudo 权限 在 /etc/sudoers 中加入 devjue ALL=(ALL) ALL，并保存退出。\n$ vim /etc/sudoers ... ## Allow root to run any commands anywhere root ALL=(ALL) ALL fabric ALL=(ALL) ALL ...  初始化 fabric 的用户目录 切换至 fabric 账户：\n$ su fabric  在 fabric 的用户根目录，创建目录 bin/、lib/、opt/ 和 download/。其中，bin/ 存放应用程序的软链接，lib/ 存放第三方库，opt/ 存放用户 fabric 自己的应用程序，download 存放源码包等下载资源。\n$ mkdir $HOME/bin $ mkdir $HOME/lib $ mkdir $HOME/opt $ mkdir $HOME/download   $HOME 是 fabric 的用户根目录，即 /home/fabric。\n 设置环境变量 把 bin/、lib/ 加入环境变量。\n$ echo -e '\\nPATH=$HOME/bin:$PATH\\nexport LD_LIBRARY_PATH=$HOME/lib' \u0026gt;\u0026gt; $HOME/.bash_profile  使用 sudo 安装软件 安装基础库 $ sudo yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel \\ readline-devel tk-devel libffi-devel gcc gcc-c++ make bzip2 git  安装 Docker $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo $ sudo yum-config-manager --enable docker-ce-edge $ sudo yum-config-manager --enable docker-ce-test $ sudo yum install -y docker-ce $ sudo yum install -y docker-compose  如果无法通过 yum 安装 containerd.io 先下载 rpm 包，然后离线安装。\n$ wget https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm $ sudo yum -y install containerd.io-1.2.6-3.3.el7.x86_64.rpm  如果无法通过 yum 安装 Docker-compose 直接下载可执行文件。然后将其移入 bin/ 目录。\n$ wget https://github.com/docker/compose/releases/docker-compose-Linux-x86_64 $ mv docker-compose-Linux-x86_64 ~/bin/docker-compose $ docker-compose --version  启动 Docker 服务 $ sudo systemctl start docker  安装 Golang 下载已编译好的 Go 安装包。注意，Fabric v1.4.4 必须使用 Go 1.12.x 版本。然后，将解压后的目录 go/ 移动到目录 $HOME/opt 下。设置环境变量 GOROOT、GOPATH，并将这两个目录下的 bin/ 加入 PATH。\n$ cd $HOME/download $ wget https://studygolang.com/dl/golang/go1.12.14.linux-amd64.tar.gz $ tar zxvf go1.12.14.linux-amd64.tar.gz $ mv go $HOME/opt $ sudo sed -i '$a export GOROOT='$HOME'/opt/go\\nexport GOPATH='$HOME'/gopath\\n\\ export PATH=$PATH:$GOROOT/bin:$GOPATH/bin\\n' /etc/profile  设置代理 在以后 Fabric 的编译过程中，需要访问 golang.org，如果不能访问的话，需要设置代理。为了方便，我们也将其写入 /etc/profile。\n$ sudo sed -i '$a export GOPROXY=https://goproxy.io' /etc/profile  立即生效 由于稍后安装 Fabric 时需要使用 $GOPATH，所以让 Golang 的环境配置立即生效。\n$ source /etc/profile  使用用户权限安装软件 安装 Python2.7 从 Python 官网下载 Python2.7.17 源码，使用 configure 的 --prefix 参数将 Python2.7 安装在 $HOME/opt/ 目录下。然后，将刚安装好的 python 和 python2 软链接到 $HOME/bin/ 目录下。由于稍后安装 node.js 时需要 python2.7，所以执行 source $HOME/.bash_profile 让其立即生效。\n$ cd $HOME/download $ wget https://www.python.org/ftp/python/2.7.17/Python-2.7.17.tgz $ tar zxvf Python-2.7.17.tgz $ cd Python-2.7.17 $ ./configure --prefix=$HOME/opt/Python $ make -j8 $ make install $ ln -s $HOME/opt/Python/bin/python $HOME/bin/ $ ln -s $HOME/opt/Python/bin/python2 $HOME/bin/ $ source $HOME/.bash_profile  安装 node.js 升级 gcc-c++ CentOS 的 gcc-c++ 版本可能较低，需要升级版本。使用 yum 安装，并立即生效。\nsudo yum -y install centos-release-scl sudo yum -y install devtoolset-8-gcc devtoolset-8-gcc-c++ devtoolset-8-binutils source /opt/rh/devtoolset-8/enable  下载并安装 与安装 Python2.7 相似，从 node.js 官网下载 node-v12.13.0 源码，使用 configure 的 --prefix 参数将 node.js 安装在 $HOME/opt/ 目录下。最后，将刚安装好的 node 和 npm 软链接到 $HOME/bin/ 目录下。\n$ cd $HOME/download $ wget https://nodejs.org/dist/v12.13.0/node-v12.13.0.tar.gz $ tar zxf node-v12.13.0.tar.gz $ cd node-v12.13.0 $ ./configure --prefix=$HOME/opt/nodejs $ make -j8 $ make install $ ln -s $HOME/opt/nodejs/bin/node $HOME/bin/ $ ln -s $HOME/opt/nodejs/bin/npm $HOME/bin/  安装 Hyperledger Fabric 在 $GOPATH 目录下创建目录 src/github.com/hyperledger。然后，克隆 Hyperledger Fabric 项目，并检出 v1.4.4。\n$ mkdir -p $GOPATH/src/github.com/hyperledger $ cd $GOPATH/src/github.com/hyperledger $ git clone -b master https://github.com/hyperledger/fabric.git \\ \u0026amp;\u0026amp; cd fabric \u0026amp;\u0026amp; git checkout v1.4.4  安装 Fabric Samples Fabric 的目录 scripts/ 有 bootstrap.sh 文件。它有三个作用，第一，从 GitHub 上克隆与 Fabric 当前版本对应的 Fabric Samples；第二，从 nexus.hyperledger.org 下载二进制文件；第三，下载 docker image。直接运行这个脚本即可。\n$ cd $GOPATH/src/github.com/hyperledger/fabric/scripts $ sudo bash bootstrap.sh  软件版本 本文涉及的软件版本如下：\n CentOS Linux release 7.5.1804 (Core) Docker 19.03.5 Docker-compose 1.18.0 go 1.12.14 Python-2.7.17 node v12.13.0 npm 6.12.0 Hyperledger-Fabric v1.4.4 Fabric Samples v1.4.4  参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/prereqs.html https://goproxy.io/\n","id":3,"section":"posts","summary":"Hyperledger Fabric 需要 Docker、Golang、Node.js 和 Python2.7。Docker 容器用来启动 Fabric 的各个组件镜像。Go 是 Fabric 的开发语言，我们需","tags":["Hyperledger","Fabric"],"title":"Hyperledger Fabric 环境安装","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","year":"2019"},{"content":" 网络完全形成 让我们使用一致的视觉词汇来回顾一下我们的网络。我们已经使用更紧凑的视觉语法对其进行稍微的重组，因为它可以更好地适应更大的拓扑：\n在这张图中，我们看到 Fabric 区块链网络由两个应用程序通道和一个排序服务通道组成。组织 R1 和 R4 负责排序服务通道，R1 和 R2 负责蓝色应用程序通道，而 R2 和 R3 负责红色应用程序通道。客户端应用程序 A1 是组织 R1 的一个元素，CA1 是它的证书颁发机构。注意，组织 R2 的 peer P2 可以使用蓝色和红色应用程序通道的通信设施。每一个应用程序通道都有自己的通道配置，在这个例子中是 CC1 和 CC2。系统通道的通道配置是网络配置 NC4 的一部分。\n我们在构建示例 Hyperledger Fabric 区块链网络概念之旅结束时。我们已经创建了一个具有四个组织、两个通道、三个 peer 节点、两个智能合约和一个排序服务的网络。它由四个证书颁发机构支持。它为三个客户端应用程序提供账本和智能合约服务，我们可以通过两个通道与其进行交互。花一点时间浏览一下图中网络的细节，并随意回看此主题以增强您的知识，或者转到更详细的主题。\n网络组件摘要 这是我们讨论过的网络组件的概要：\n Ledger. 每个通道都有一个。包括 Blockchain 和 World state 。 Smart contract (aka chaincode) Peer nodes Ordering service Channel Certificate Authority  网络总结 在本主题中，我们已经看到不同组件如何共享其基础设施，以提供一个完整的 Hyperledger Fabric 区块链网络。我们已经看到共有的基础设施如何组成通道，以提供独立管理的私密通信机制。我们已经看到像客户端应用程序、管理员、peer 和排序者这些参与者，如何使用来自它们各自证书颁发机构的证书来识别其来自不同的组织。反过来，我们已经看到，定义协商一致权限的策略的重要性，这些权限是在网络和通道资源上组织的参与者所拥有的。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#network-fully-formed\n","id":4,"section":"posts","summary":"网络完全形成 让我们使用一致的视觉词汇来回顾一下我们的网络。我们已经使用更紧凑的视觉语法对其进行稍微的重组，因为它可以更好地适应更大的拓扑： 在","tags":["Hyperledger","Fabric","翻译"],"title":"Hyperledger Fabric 1.4 官方文档翻译之七：Key Concepts - Blockchain network (7)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%B8%83key-concepts-blockchain-network-7/","year":"2019"},{"content":" 使用 GitHub 创建一个仓库，用于对 Hugo 博客的版本进行管理。有了 GitHub 仓库后，还可以在多终端（个人电脑、工作电脑等）上同时撰写博客。\n初始化本地仓库 $ cd /path/to/site/ $ git init $ git remote add origin git@github.com:yourname/yourblog.git  进入 Hugo 站点目录 /path/to/site/，初始化 git，并将 git@github.com:yourname/yourblog.git（这个仓库已经提前创建，且没有提交记录）设置为你的远程仓库。\n选择需要提交的文件 跟踪空目录 刚初始化的 Hugo 博客目录如下所示：\narchetypes/ default.md content/ data/ layouts/ static/ themes/  可见，除了 archetypes/，其它都是空目录。\n由于 git 只跟踪文件的变动，不跟踪目录。所以，即便使用 git add，没有文件的空目录也不会被提交到暂存区。针对这一点，如果想提交站点的完整结构，需要在空目录下添加文件，这个文件可以没有任何内容。有一个惯例做法是向想要提交的空目录中添加名为 .gitkeep 的空文件，此文件的作用只是让其所在的目录被提交。\n$ touch content/.gitkeep data/.gitkeep layouts/.gitkeep static/.gitkeep themes/.gitkeep  忽略 public/ 目录 由于 public/ 目录下的文件完全是由 Hugo 生成的，我们可以随时生成最新的内容，所以建议不提交该目录。\n$ echo \u0026quot;public/\u0026quot; \u0026gt;\u0026gt; .gitignore  在 .gitignore 中加入 public/，目录 public/ 及其路径下的所有文件将不会被提交。\n添加子模块 Hugo 中有很多主题可选，这为写博客带来了很大的便利及乐趣。这些主题大多是 GitHub 上的项目，如果我们想跟踪主题的更新，及时获取其最新版本，推荐将该主题的项目作为子模块添加到我们的博客项目中。还是以我选择的 主题 pure 为例：\n$ git submodule add git@github.com:xiaoheiAh/hugo-theme-pure.git themes/pure  提交到远程仓库 GitHub 最后，提交目录下的所有文件。\n$ git add -A $ git commit -m \u0026quot;init blog\u0026quot; $ git push -u origin master  克隆子模块 当我们使用 git clone git@github.com:yourname/yourblog.git 克隆项目时，子模块是不会被克隆的。下面介绍两个方法来克隆子模块。\n使用 git submodule 先克隆项目，再根据需要克隆子模块。\n$ git clone git@github.com:yourname/yourblog.git $ cd yourblog $ git submodule init $ git submodule update  使用 --recurse-submodules 在克隆项目时，就克隆其子模块。\n$ git clone git@github.com:yourname/yourblog.git --recurse-submodules   注意，当在新环境中使用 Hugo 生成静态站点时，需要先克隆作为子模块的 Hugo 主题。\n ","id":5,"section":"posts","summary":"使用 GitHub 创建一个仓库，用于对 Hugo 博客的版本进行管理。有了 GitHub 仓库后，还可以在多终端（个人电脑、工作电脑等）上同时撰写博客。 初始化本地仓库 $ cd /path/to/site/ $ git","tags":["git"],"title":"Hugo 博客搭建之三：使用 GitHub 对博客版本进行管理","uri":"https://devjue.github.io/2019/12/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E4%B8%89%E4%BD%BF%E7%94%A8github%E5%AF%B9%E5%8D%9A%E5%AE%A2%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86/","year":"2019"},{"content":" https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#joining-a-peer-to-multiple-channels\n把 peer 加入多个通道 在网络开发的最后阶段，让我们将重点转回到组织 R2。我们可以利用 R2 同时是联盟 X1 和 X2 成员的事实，将 R2 加入多个通道：\n这张图显示了网络 N 中与通道 C1 和 C2 有关的如下实际情况：应用程序 A1 可以使用通道 C1 与 peer P1、P2 和排序服务 O4 进行通信；应用程序 A2 可以使用通道 C1 与 peer P1 和 P2 进行通信，并使用通道 C2 与 peer P2、P3 和排序服务 O4 进行通信。应用程序 A3 可以使用通道 C2 与 peer P3、P2 和排序服务 O4 进行通信。排序服务可以利用通道 C1 和 C2 的通信服务。通道配置 CC1 适用于通道 C1，CC2 适用于通道 C2。\n我们可以看到，R2 是网络中的一个特殊组织，因为它是唯一一个同时是两个应用程序通道成员的组织！它可以在通道 C1 上与组织 R1 进行交易，同时还可以在不同的通道 C2 上与组织 R3 进行交易。\n注意，peer 节点 P2 如何为通道 C1 安装智能合约 S5，并为通道 C2 安装智能合约 S6。peer 节点 P2 为了不同的账本，同时通过不同的智能合约成为两个通道共同的成员。\n这是非常强大的概念——通道同时提供组织隔离的机制和组织间协作的机制。一直以来，此基础设施是由一组独立的组织提供并在其之间共享的。\n同样需要非常注意，peer 节点 P2 的行为受其进行交易的通道的非常不同的控制。具体而言，通道配置 CC1 中的策略规定了当 P2 在通道 C1 中进行交易时，P2 可使用的操作，而通道配置 CC2 中的策略控制 P2 在通道 C2 中的行为。\n同样，这是理想的——R2 和 R1 为通道 C1 的规则达成一致，而 R2 和 R3 位通道 C2 的规则达成一致。这些规则在各自的通道策略中捕获——通道中的组件可以而且必须遵照达成的共识，使用这些策略来强制执行正确的操作。\n类似地，我们可以看到客户端应用程序 A2 现在可以在通道 C1 和 C2 上进行交易。同样，它也将由适当的通道配置中的策略控制。注意，客户端应用程序 A2 和 peer 节点 P2 正在使用混合视觉词汇——线和连接点。您可以看到它们是等效的，是视觉同义词。\n排序服务 细心的读者可能会发现排序服务似乎是一个集中式的组件；它最初用于创建网络，并在网络中连接每一个通道。即使我们把 R1 和 R4 添加到控制排序者的网络配置策略 CN4 中，该节点仍在 R4 的基础设施上运行。在去中心化的世界里，这看上去是错误的！\n别担心！我们的示例网络展示了最简单的排序服务配置，来帮助您理解网络管理的核心概念。事实上，排序服务自己也可以是去中心化的！我们前面提到排序服务可以由不同组织拥有的许多独立节点组成，因此让我们看看如何在示例网络中完成该工作。\n让我们看一下更现实的排序服务节点配置：\n多个组织的排序服务。排序服务由排序服务节点 O1 和 O4 组成。O1 由组织 R1 提供，O4 由组织 R4 提供。网络配置 NC4 为组织 R1 和 R4 的参与者定义网络资源权限。\n我们可以看到，该排序服务完全去中心化——它既在组织 R1 中运行，也在组织 R4 中运行。网络配置策略 NC4 允许 R1 和 R4 在网络资源上享有同等权限。组织 R1 和 R4 的客户端应用程序和 peer 节点，可以通过连接到节点 O1 或节点 O4 来管理网络资源，因为 O1 和 O4 这两个节点的行为一致，就像网络配置 NC4 中策略定义的那样。实践中，来自特定组织的参与者往往使用它们自己组织提供的基础设施，但也并不总是这样。\n去中心化的交易分发 除了作为网络管理核心，排序服务还提供了另一个关键功能——他是交易的分发核心。排序服务是一个从应用程序中收集已背书交易，并将其按序打包进交易区块的组件。随后，这些区块将分发到通道中的每一个 peer 节点。这些提交节点中的每一个都记录交易，不论交易有效或者无效，并相应地更新它们本地的账本副本。\n注意，排序服务节点 O4 在通道 C1 上与它在网络 N 上扮演的角色非常不同。当在通道层面时，O4 的作用是在通道 C1 中收集交易并分发区块。它依据通道配置 CC1 中定义的策略而工作。相反，当在网络层面时，O4 的作用是为网络资源提供管理核心，它依据的是网络配置 NC4 中定义的策略。再次注意，这些作用是如何被不同的通道和网络配置各自定义的。这应该使您增强了在 Hyperledger Fabric 中根据配置声明策略的重要性。策略既定义了联盟中每个成员协商一致的行为，也被其所控制。\n我们可以看到，排序服务，像 Hyperledger Fabric 中的其它组件一样，是完全去中心化的组件。不论作为网络管理核心或是通道中区块的分发者，它的节点都可以根据需要分布在网络的多个组织中。\n变更策略 在示例网络的探索过程中，我们已经了解到系统中策略对控制参与者行为的重要性。我们只讨论了一小部分可用的策略，而还有很多可以被声明定义，以控制行为的各个方面。这些单独的策略会在文档的其它地方进行讨论。\n最终要的是，Hyperledger Fabric 提供了一个唯一强大的策略，它允许网络和通道管理员自行管理策略的变更！基本的哲学是无论在组织内部或之间发生，或是由外部监管者推行，策略变更是一致性的。例如，新的组织可能加入通道，或者已存在的组织拥有的权限可能增加或减少。让我们进一步研究 Hyperledger Fabric 中的变更策略如何实施。\n理解的关键点是策略变更是策略自行管理的。修改策略，或简称 mod_policy，是网络或者通道配置中管理变更的第一种策略。让我们给两个已经在网络中使用 mod_policy 管理变更的简单例子。\n第一个例子是网络初始化的时候。此时，只有组织 R4 被允许管理网络。实践中，这是通过使 R4 成为网络配置 NC4 中定义的唯一拥有网络资源许可的组织来实现的。此外，NC4 的 mod_police 只提及组织 R4——只有 R4 被允许来更改配置。\n然后，我们对网络 N 进行了演进，允许组织 R1 也可以管理网络。R4 通过把 R1 添加到用于通道创建和联盟创建的策略中来做到这一点。由于此更改，R1 能够定义联盟 X1 和 X2，并创建通道 C1 和 C2。R1 对网络配置中的通道和联盟策略具有同等的管理权限。\n但是，R4 可以通过网络配置给 R1 授予更多的权限！R4 可以把 R1 添加到 mod_policy 中，以便 R1 也能够管理网络策略的变更。\n第二个例子比第一个更强大，因为 R1 现在对网络配置 NC4 拥有完全控制权限！这意味着 R1 原则上可以从网络中删除 R4 点管理权限。在实践中，R4 将配置 mod_policy，以便 R4 也需要批准更改，或者 mod_policy 中的所有组织都必须批准更改。有很大的灵活性使 mod_policy 复杂到可以支持所需的任何更改流程。\n这是工作中的 mod_policy ——它被允许从基本配置向复杂配置优雅地演进。所有组织参与达成一致的情况总在发生。mod_policy 的行为类似网络或通道配置中的每个其它策略，它定义了一组允许改变 mod_policy 本身的组织。\n在本小节中，我们仅涉及了策略的权限和特定的 mod_policy。在策略主题中将对其进行更详细的讨论，但现在让我们回到完成的网络中！\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#joining-a-peer-to-multiple-channels\n","id":6,"section":"posts","summary":"https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#joining-a-peer-to-multiple-channels 把 peer 加入多个通道 在网络开发的最后阶段，让我们将重点转回到组织 R2。我们可以利用 R2 同时是联盟 X1 和 X2 成员的事实，将 R2 加入多个通道： 这张图显示了","tags":["Hyperledger","Fabric","翻译"],"title":"Hyperledger Fabric 1.4 官方文档翻译之六：Key Concepts - Blockchain network (6)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E5%85%ADkey-concepts-blockchain-network-6/","year":"2019"},{"content":" 添加另一个联盟定义 在网络开发的下一阶段，我们介绍组织 R3。我们将要为组织 R2 和 R3 提供一个单独应用程序通道，使他们能够互相交易。这个应用程序通道将与之前定义的通道完全分开，因此 R2 和 R3 的交易可以对它们保持私密。\n让我们回到网络层面，为 R2 和 R3 定义一个新联盟 X2：\n组织 R1 或 R4 的网络管理员添加了一个新联盟定义 X2，包括组织 R2 和 R3。这将用于为 X2 定义新通道。\n注意，网络现在有两个联盟定义：组织 R1 和 R2 的 X1，组织 R2 和 R3 的 X2。引入联盟 X2，是为了能够为 R2 和 R3 创建新通道。\n新通道只能被那些在网络配置策略 NC4 中明确标识为拥有相应权限的组织（即 R1 或 R4）创建。这是一个策略的示例，该策略可以区分出可以在网络层面管理资源的组织和可以在通道层面管理资源的组织。看到这些策略在起作用，有助于我们理解为什么 Hyperledger Fabric 具有复杂的分层策略结构。\n在实践中，联盟定义 X2 已经被添加到网络配置 NC4 中。我们将在文档的其它地方讨论这些操作的确切机制。\n添加新通道 让我们现在使用新的联盟定义 X2 创建一个新通道 C2。为了帮助加强您对这个简化通道记号的理解，我们同时使用两种视觉形式——通道 C1 使用蓝色圆圈端点表示，而通道 C2 使用红色连接线表示：\n使用联盟定义 X2 为 R2 和 R3 创建了一个新通道 C2。该通道有完全独立于网络配置 NC4 的通道配置 CC2 和通道配置 CC1。通道 C2 由 R2 和 R3 管理，它们具有 CC2 中策略定义的对 C2 的同等权限。R1 和 R4 在 CC2 中均未被定义任何权限。\n通道 C2 为联盟 X2 提供了私密通讯机制。再次注意，联盟中的组织联合起来是通过什么形式的通道。通道配置 CC2 现在包含管理通道资源的策略，通过通道 C2 给组织 R2 和 R3 分配管理权限。它仅由 R2 和 R3 管理，R1 和 R4 在通道 C2 中没有权限。例如，随后可以更新通道配置 CC2 以添加组织来支撑网络增长，但这些只能由 R2 或 R3 完成。\n注意，通道配置 CC1 和 CC2 如何保持彼此完全独立，并与网络配置 NC4 完全独立。再次，我们看到 Hyperledger Fabric 网络的去中心化特性；通道 C2 一旦创建，它将被组织 R2 和 R3 独立于其它网络元素来管理。通道策略总是保持彼此独立，并只能由有权在通道中这样做的组织进行更改。\n随着网络和通道的发展，网络和通道的配置也将随之发展。这是一个通过受控的方式完成的过程——涉及配置交易，这些交易包括这些配置的更改。每个配置的更改都会导致一个新的配置区块交易生成，在本主题的后面，我们将看到这些区块如何被验证和接受，以便分别创建更新的网络和通道配置。\n网络和通道配置 在整个示例网络中，我们看到网络和通道配置的重要性。这些配置非常重要，因为它们封装了网络成员达成一致的策略，这些策略对控制访问网络资源提供了共享参考。网络和通道配置还包含有关网络和通道组成的实际情况，例如联盟的名称及其组织。\n例如，当使用排序服务节点 O4 首次生成网络时，其行为被网络配置 NC4 控制。NC4 的初始配置只包含允许组织 R4 管理网络资源的策略。随后，NC4 被更新为还允许 R1 管理网络资源。进行此更新后，组织 R1 或 R4 中连接到 O4 的任何管理员将拥有网络管理权限，因为这是网络配置 NC4 中策略许可的。在内部，排序服务中的每一个节点都会记录网络配置中的每个通道，因此在网络层面有每个通道创建的记录。\n这意味着，虽然排序服务节点 O4 是创建联盟 X1 和 X2 以及通道 C1 和 C2 的参与者，但是网络的智能包含在 O4 遵循的网络配置 NC4 中。只要 O4 表现良好，并且在处理网络资源时正确地实施在 NC4 中定义的策略，我们的网络将做出所有组织都同意的行为。在许多方面，NC4 都比 O4 更重要，因为它最根本地控制网络访问。\n相同的原则适用于有关 peer 的通道配置。在我们的网络中，P1 和 P2 都是好的执行者。当 peer 节点 P1 和 P2 与客户端应用程序 A1 或 A2 交互时，它们每个都使用通道配置 CC1 中定义的策略来控制对通道 C1 资源的访问。\n例如，如果 A1 想要访问在 peer 节点 P1 或 P2 上的智能合约链码 S5 时，每个 peer 节点使用其 CC1 的副本来确定 A1 可以访问的操作。例如，根据 CC1 中的策略定义，允许 A1 从账本 L1 上读写数据。稍后我们将看到在通道及其通道配置 CC2 中的参与者有同样的模式。再次，我们可以看到，peer 和应用程序是网络中的关键角色。但它们在通道中的行为更多地由通道配置策略决定，而不是任何其它因素。\n最后，了解网络和通道配置如何在物理上存在将很有帮助。我们可以看到，网络和通道配置在逻辑上是唯一的——网络有一个，每个通道有一个。这非常重要，访问网络或通道的每一个组件必须对授予不同组织的权限有共同的理解。\n即使逻辑上是一个配置，但实际上它被构成网络或通道的每一个节点复制并保持一致。例如，在我们的网络中 peer 节点 P1 和 P2 都拥有通道配置 CC1 的副本，而到网络完成时， peer 节点 P2 和 P3 将都拥有通道配置 CC2 的副本。类似地，排序服务节点 O4 拥有网络配置的副本，但在多节点配置中，每一个排序服务节点都将拥有它自己的网络配置副本。\n网络和通道配置保持一致，使用的是与用于用户交易相同的区块链技术，而不只用于配置交易。。要改变网络或通道配置，管理员必须提交配置交易来改变网络或通道配置。它必须由恰当的策略中确定负责配置变更的组织签名。该策略被称为 mod_policy，我们将稍后讨论它。\n的确，排序服务节点运行着一个迷你区块链，通过我们前面提到的系统通道连接。排序服务节点使用系统通道分发网络配置交易。这些交易用于在每个排序服务节点上合作维护网络配置的一致性副本。类似的方式，应用程序通道中的 peer 节点可以分发通道配置交易。同样的，这些交易用于在每个 peer 节点上维护通道配置的一致性副本。\n逻辑上唯一性与物理上分布式之间的这种平衡是 Hyperledger Fabric 中常见的模式。例如，像网络配置，逻辑上是单一的，但实际上是物理上在一组排序服务节点中进行复制的。我们还看到通道配置、账本以及某种程度上的智能合约，它们安装在多个地方，但它们的接口逻辑上存在于通道层面。您会在 Hyperledger Fabric 中一次又一次地看到这种模式，它使得 Hyperledger Fabric 既去中心化又可管理。\n添加另一个 peer 既然组织 R3 能够完全参与通道 C2，让我们把它的基础组件添加进该通道中。我们将一次性添加 peer 及其账本的本地副本、智能合约和客户端应用程序，而不是每次只添加一个组件！\n让我们看一下添加了组织 R3 的组件的网络：\n这张图显示了与网络 N 中的通道 C1 和 C2 的如下实际情况：客户端应用程序 A1 和 A2 可以使用通道 C1 与 peer P1、P2 和排序服务 O4 通信；客户端应用程序 A3 可以使用通道 C2 与 peer P3 和排序服务 O4 通信。通信服务 O4 可以利用通道 C1 和 C2 的通信服务。通道配置 CC1 适用于通道 C1，CC2 适用于通道 C2。\n首先，请注意，由于 peer 节点 P3 连接到通道 C2，因此它对那些使用通道 C1 的 peer 节点有不同的账本 L2。账本 L2 的有效作用域是通道 C2。账本 L1 是完全独立的，它的作用域是通道 C1。这是有道理的——通道 C2 的目的是在联盟 X2 的成员之间提供私密通信，账本 L2 是其交易的私密存储。\n类似的方式，在 peer 节点 P3 上安装并在通道 C2 上实例化的智能合约 S6，用于提供对账本 L2 的受控访问。应用程序 A3 现在可以使用通道 C2 调用由智能合约 S6 提供的服务生成交易，这些交易可以被网络中账本 L2 的每一个副本接受。\n此时，我们有了一个定义了两个完全独立通道的网络。这些通道为组织之间的相互交易提供了独立管理的设施。同样地，这是去中心化的工作，我们有一个在控制和自治之间的平衡。这是通过应用于受到不同组织控制和影响的通道上的策略来实现的。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#adding-another-consortium-definition\n","id":7,"section":"posts","summary":"添加另一个联盟定义 在网络开发的下一阶段，我们介绍组织 R3。我们将要为组织 R2 和 R3 提供一个单独应用程序通道，使他们能够互相交易。这个应用程序通道","tags":["Hyperledger","Fabric","翻译"],"title":"Hyperledger Fabric 1.4 官方文档翻译之五：Key Concepts - Blockchain network (5)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%BA%94key-concepts-blockchain-network-5/","year":"2019"},{"content":" 网络完成 回想一下，我们的目标是为联盟 X1（组织 R1 和 R2）创建一个通道。网络开发的下一节会看到组织 R2 把它的基础设施添加到网络中。\n让我们看一下网络是如何演进的：\n通过增加组织 R2 的基础设施，网络得到了发展。具体来说，R2 添加了 peer 节点 P2，该 peer 节点托管账本 L1 的副本和链码 S5。应用程序 A2 加入了通道 C1，P2 也与它一样加入了通道 C1。A2 和 P2 使用来自 CA2 的证书进行标识。所有这些意味着应用程序 A1 和 A2 都可以使用 peer 节点 P1 或 P2 在 C1 上调用 S5。\n我们可以看到组织 R2 在通道 C1 上添加了一个 peer 节点 P2。P2 还托管账本 L1 和智能合约 S5 的副本。我们可以看到 R2 还添加了可以通过通道 C1 连接到网络的客户端应用程序 A2。为此，组织 R2 中的管理员已创建 peer 节点 P2，并将其加入通道 C1，方法与 R1 中的管理员相同。\n我们已经建立了第一个运营网络！在网络开发的现阶段，我们拥有一个通道，组织 R1 和 R2 可以彼此进行完整交易。具体来说，这意味着应用程序 A1 和 A2 可以使用智能合约 S5 和账本 L1 在通道 C1 上生成交易。\n生成和接受交易 与总是持有账本副本的 peer 节点相反，我们看到存在两种不同的 peer 节点：持有智能合约的节点和不持有智能合约的节点。（译者按：即所有的 peer 节点都持有账本的副本，但不是所有的 peer 节点都持有智能合约的副本。）在我们的网络中，每个 peer 都持有一个智能合约的副本，但是在较大的网络中，将有更多的 peer 节点不持有智能合约的副本。peer 只能在安装了智能合约的情况下运行它，但是 peer 可以连接到通道，以了解智能合约的接口。\n您不应该把不持有智能合约的 peer 节点视为低级节点。持有智能合约的 peer 节点确实有一种特殊的能力——帮助生成交易。注意，所有的 peer 节点都能够在它们的账本 L1 的副本上，验证、接受或拒绝交易。然而，只有安装智能合约的 peer 节点才能够参与到交易背书的过程中，这对生成有效交易至关重要。\n在本篇文章中，我们无需关心交易如何生成、分发和接受的确切细节，已足够了解我们拥有一个区块链网络，组织 R1 和 R2 可以将信息和流程共享为账本已捕获的交易。在其它主题中，我们将学习到更多有关交易、账本、智能合约的内容。\npeer 的类型 在 Hyperledger Fabric 中，尽管所有 peer 都相同，但是它们可以根据网络的配置方式承担多个角色。现在，我们对典型的网络拓扑有了足够的了解，可以描述这些角色。\n 提交节点（Committing peer）。通道中的每个 peer 节点都是提交节点。它接收生成的交易的块，并随后验证它们，然后再将它们提交到 peer 节点的账本副本作为追加操作。\n 背书节点（Endorsing peer）。如果安装了智能合约，每个 peer 都可以成为背书节点。然而，实际上要成为背书节点，peer 上的智能合约必须被客户端应用程序用来生成数字签名的交易应答。\n  智能合约的背书策略标识了组织，其 peer 应先对生成的交易进行数字签名，然后才能将其接受到提交节点的账本副本中。\n这是 peer 的两种主要类型。peer 可以采用其它两个角色：\n 领导节点（Leader peer）。当组织在一个通道中有多个 peer 时，领导节点是负责将交易从排序者分发到组织中其它提交节点的节点。peer 可以参与静态或动态的领导选择。  因此，从领导者的角度思考两组 peer 是有帮助的——那些具有静态领导者选择的 peer 和那些具有动态领导者选择的 peer。对于静态组，零个或多个 peer 可以被配置为领导者。对于动态组，只能有一个 peer 将被选择为领导者。此外，在动态组中，如果领导节点失效，那么其余 peer 将重新选择领导者。\n这意味着组织的 peer 可以有一个或多个领导者连接到排序服务。这可以帮助提高在大型网络中处理大量交易的弹性和可伸缩性。\n 锚节点（Anchor peer）。如果 peer 节点需要与另一个组织中的 peer 通信，它可以使用该组织通道配置中定义的锚节点中的一个。一个组织可以为其定义零个或多个锚节点，并且锚节点可以帮助处理不同的跨组织通信场景。  注意，一个 peer 可以同时是一个提交节点、背书节点、领导节点和锚节点。只有锚节点是可选的——出于所有实际目的，总会有一个领导节点，至少有一个背书节点，至少有一个提交节点。\n安装而不是实例化 和组织 R1 一样的方法，组织 R2 必须将智能合约 S5 安装到它的 peer 节点上。这很明显——如果应用程序 A1 或 A2 希望在 peer 节点 P2 上使用 S5 生成交易，那么 S5 必须存在，安装是确保这发生的机制。此时，peer 节点 P2 拥有智能合约和账本的物理副本，像 P1 一样，它可以在其账本 L1 上同时生成和接受交易。\n然而，与组织 R1 相比，组织 R2 不需要在通道 C1 上实例化智能合约 S5。这是因为 S5 已经被组织 R1 在通道中实例化了。实例化只需要发生一次。随后加入通道的任何 peer 都知道智能合约 S5 在该通道中可用。这些反映了这样一个事实，账本 L1 和智能合约实际上以物理的形式存在于 peer 节点上，以逻辑的形式存在于通道上，R2 只是将另一个 L1 和 S5 的物理实例添加到网络上。\n在我们的网络中，我们可以看到通道 C1 连接了两个客户端应用程序，两个 peer 节点和一个排序服务。由于只有一个通道，所以只有一个逻辑账本与这些组件进行交互。peer 节点 P1 和 P2 有账本 L1 完全相同的副本。智能合约 S5 的副本通常使用同样的编程语言完全相同地实现，但如果不同，他们必须在语义上等效。\n我们可以看到，小心地将 peer 添加到网络可以帮助支持增长的吞吐量、稳定性和弹性。例如，网络中更多的 peer 允许更多的应用程序连接到它；如果发生计划内或计划外的停机，组织中更多的 peer 将提供额外的弹性。\n这一切都意味着，可以配置支持各种业务目标的复杂拓扑——网络可达到理论上没有限制的规模。此外，单个组织中的 peer 有效地发现并彼此通信的技术机制——gossip 协议——将容纳大量 peer 节点，以支持这样的拓扑。\n谨慎使用网络和通道策略可以使甚至大型网络都得到良好的管理。组织可以自由地将 peer 节点加入到网络，只要他们遵守网络约定的策略即可。网络和通道策略在自治和控制之间建立平衡，这是去中心化网络的特征。\n简化视觉词汇 现在，我们将简化用于表示我们示例区块链网络的视觉词汇。随着网络规模的增长，最初帮助我们理解通道的线将变得很繁琐。想象一下，如果我们添加另一个 peer 或客户端应用程序，或者另一个通道，图将变得多么复杂？\n这就是我们将在一分钟内做的事情，在我们这样做之前，让我们简化视觉词汇。这是到目前为止我们开发的网络的简化表示：\n这张图展示了与网络 N 有关的如下事实：客户端应用程序 A1 和 A2 可以使用通道 C1 与 peer P1、P2 和排序者 O4 进行通信。peer 节点 P1 和 P2 可以使用通道 C1 的通信服务。排序服务 O4 可以利用通道 C1 的通信服务。通道配置 CC1 应用于通道 C1。\n注意，这张网络已经用连接点代替通道线进行了简化，显示为包含通道数字的蓝色圆圈。没有信息损失。这个表示更具有伸缩性，因为它消除了交叉线。这使我们可以更清晰地表示更大的网络。我们通过聚焦于组件和通道之间的连接点，而不是通道本身的方式，达到了这样的简化。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#network-completed\n","id":8,"section":"posts","summary":"网络完成 回想一下，我们的目标是为联盟 X1（组织 R1 和 R2）创建一个通道。网络开发的下一节会看到组织 R2 把它的基础设施添加到网络中。 让我们看一下网","tags":["Hyperledger","Fabric","翻译"],"title":"Hyperledger Fabric 1.4 官方文档翻译之四：Key Concepts - Blockchain network (4)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E5%9B%9Bkey-concepts-blockchain-network-4/","year":"2019"},{"content":" peer 和账本 现在，让我们使用通道把区块链网络和组织连接起来。在网络开发的下一阶段，我们可以看到网络 N 获得了两个新组件，即 peer 节点 P1 和账本实例 L1。\nPeer 节点 P1 已加入通道 C1，P1 物理上托管账本 L1 的副本。P1 和 O4 可以使用 C1 相互通信。\npeer 节点是托管区块链账本副本的网络组件！最后，我们开始看到一些可识别的区块链组件！P1 在网络中的目的纯粹是托管账本 L1 的副本，以供其他人访问。我们可以认为 L1 物理上托管在 P1 上，但逻辑上托管在通道 C1 上。当我们向通道添加更多 peer 时，我们会更清楚地看到这个想法。\nP1 配置的关键部分是 CA1 发出的 X.509 身份，该身份将 P1 与组织 R1 相联。P1 一旦启动，它就可以使用排序者 O4 加入 C1。当 O4 收到加入申请时，将使用 CC1 来确定 P1 在此通道上的权限。例如，CC1 决定 P1 是否可以在 L1 上进行读写操作。\n注意，peer 如何被拥有它们的组织加入到通道中，以及虽然我们只添加了一个 peer，但是将看到网络中的多个通道上可以有多个 peer 节点。我们马上将看到 peer 可以扮演不同角色。\n应用程序和智能合约链码 现在，通道 C1 上有一份账本，我们可以开始连接客户端应用程序，来使用由账本、peer 提供的一些服务！\n注意，网络是如何成长的：\n智能合约 S5 已安装到 P1 上。组织 R1 中的客户端应用程序 A1 可以使用 S5 通过 peer 节点 P1 访问账本。A1，P1 和 O4 都已加入通道 C1，即它们都可以利用该通道提供的通信设施。\n在网络开发的下一个阶段，我们可以看到客户端应用程序 A1 可以使用通道 C1 连接到特殊的网络资源——在这个例子中，A1 可以连接 peer 节点 P1 和排序节点 O4。再次看到通道对网络和组织组件之间通信非常重要。就像 peer 和排序者，客户端应用程序将拥有与组织关联的身份。在我们的示例中，客户端应用程序 A1 与组织 R1 关联；虽然它在 Fabric 区块链网络之外，但仍通过通道 C1 连接到它。\n现在，看起来 A1 可以直接通过 P1 访问账本 L1，但实际上，所有访问都是通过称为智能合约链码 S5 的特殊程序进行管理的。S5 定义了所有对账本的常见访问模式；S5 提供了一套明确定义的方式，可以查询或更新账本 L1。简而言之，客户端应用程序 A1 必须通过智能合约 S5 才能到达账本 L1！\n智能合约可以由每个组织中的应用程序开发人员创建，以实现联盟成员共享业务流程。智能合约用于帮助生成交易，这些交易将被有序地分发到网络中的每个节点。 智能合约必须被安装并实例化。\n安装智能合约 智能合约 S5 开发完成后，组织 R1 中的管理员必须将其安装到 peer 节点 P1 上。这是一个简单的操作；执行后，P1 完全了解 S5。具体来说，P1 可以看到 S5 的实现逻辑——用于访问账本 L1 的程序代码。我们将其与只描述输入和输出，不考虑其实现的 S5 接口进行对比，\n当组织在一个通道中有多个 peer 时，它可以选择 peer 进行智能合约的安装。它不需要在每个 peer 上安装智能合约。\n实例化智能合约 但是，仅仅因为 P1 已经安装了 S5，连接到通道 C1 的其他组件却没有意识到；它必须首先在通道 C1 上实例化。在我们的示例中，它只有一个 peer 节点 P1，组织 R1 中的管理员必须使用 P1 在通道 C1 上实例化 S5。实例化之后，通道 C1 上的每个组件都知道 S5 的存在。在我们的示例中，这意味着 S5 现在可以由客户端应用程序 A1 调用！\n请注意，尽管通道上的每个组件现在都可以访问 S5，但它们无法看到其程序逻辑。这对于已安装它的那些节点仍然是私有的。在我们的示例中，这些节点就是 P1。从概念上讲，这意味着实例化的是智能合约接口，而不是安装的智能合约实现。加深理解，安装智能合约显示了我们如何将其物理托管在 peer 上，而实例化智能合约则显示了我们如何将其视为逻辑上由通道托管。\n背书策略 实例化提供的最重要的附加信息是背书策略。它描述了哪些组织必须在其它组织在其账本副本上接受交易前批准交易。在我们的示例网络中，交易只有被 R1 或 R2 认可后，才可以在账本 L1 上被接受。\n实例化的操作把背书策略放在通道配置 CC1 中。通道的任何成员都可以访问它。您可以在事务流主题中阅读有关背书策略的更多信息 。\n调用智能合约 智能合约安装在 peer 节点上并在通道上实例化后，即可被客户端应用程序调用。客户端应用程序通过向智能合约背书策略指定的组织所拥有的 peer 发送交易预案来完成此任务。交易预案作为智能合约的输入，智能合约使用它来生成背书交易应答，该应答由 peer 节点返回给客户端应用程序。\n这些交易应答跟交易预案打包在一起，形成了一个完全的背书交易，它可以分布在整个网络。稍后我们将更详细地介绍这一点。现在，这已足够理解应用程序是如何调用智能合约生成背书交易的了。\n在网络开发的这个阶段，我们可以看到组织 R1 完全参与网络。它的应用程序——从 A1 开始——可以通过智能合约 S5 访问账本 L1，来生成会被 R1 背书的交易。由于它们遵守背书策略，所以能够被接受到账本。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#peers-and-ledgers\n","id":9,"section":"posts","summary":"peer 和账本 现在，让我们使用通道把区块链网络和组织连接起来。在网络开发的下一阶段，我们可以看到网络 N 获得了两个新组件，即 peer 节点 P1 和账本实例 L1。","tags":["Hyperledger","Fabric","翻译"],"title":"Hyperledger Fabric 1.4 官方文档翻译之三：Key Concepts - Blockchain network (3)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%B8%89key-concepts-blockchain-network-3/","year":"2019"},{"content":" 添加网络管理员 最初，NC4 被配置为仅允许 R4 的用户拥有网络管理权限。下一阶段，我们将允许组织 R1 的用户管理网络。让我们看看网络如何演进：\n组织 R4 更新网络配置，使组织 R1 也成为管理员。此后，R1 和 R4 在网络配置上享有同等的权利。\n我们看到添加了一个新的组织 R1 作为管理员——R1 和 R4 现在对网络享有同等权利。我们还可以看到证书颁发机构 CA1 已被添加——它可以用于标示用户来自 R1 组织。此后，来自 R1 和 R4 的用户都可以管理网络。\n虽然排序节点 O4 运行在 R4 的基础设施上，但是只要 R1 获得了网络访问权限，就对其具有共享管理权限。这意味着，R1 或 R4可以更新网络配置 NC4 来允许 R2 组织拥有网络操作的子集。这样，即使 R4 正在运行排序服务，并且R1 对其拥有完全的管理权限，R2 仍对创建新联盟拥有有限权限。\n最简单的形式，排序服务在网络中是单点，这就是您在示例中看到的。排序服务通常是多节点的，并且可以被配置为在不同组织的不同节点中。例如，我们可以在 R4 中运行 O4，同时将其连接到组织 R1 中的独立排序节点 O2。这样，我们将拥有一个多站点、多组织的管理结构。\n在本篇文章的稍后部分，我们将多讨论一点排序服务，但现在只将排序服务当作管理重点，它给不同的组织提供网络的受控访问权限。\n定义联盟 虽然现在网络可以由 R1 和 R4管理，但几乎没有什么可以做的。我们需要做的第一件事是定义一个联盟。这个词的字面意思是“拥有共同命运的团体”，所以对于区块链网络中的一组组织来说是一个适当的选择。\n让我们看看如何定义一个联盟：\n网络管理员定义了一个联盟 X1，包含 R1 和 R2 两个组织成员。该联盟定义存储在网络配置 NC4 中。CA1 和 CA2 是这些组织各自的证书颁发机构。\n由于 NC4 的配置方式，只有 R1 和 R4 可以创建新的联盟。这张图展示了新联盟 X1 的加入，该联盟将 R1 和 R2 定义为它的组成组织。我们还可以看到 CA2 被添加，用来标示来自 R2 的用户。注意，一个联盟可以有任意数量的组织成员——我们刚刚展示了两个，因为它是最简单的配置。\n为什么联盟重要？我们可以看到，一个联盟定义了网络中彼此共享交易需求的组织集合——在这个例子中是 R1 和 R2。如果组织有共同的目标，将它们组合在一起会很有意义，而这确实正在发生。\n网络虽然由一个单独的组织启动，但现在由更大的一组组织所控制。我们可以以这种方式启动网络，让 R1、R2 和 R4 共享控制权，但是这让其更容易理解。\n现在，我们将使用联盟 X1 创建 Hyperledger Fabric 区块链中非常重要的一部分——通道。\n为联盟创建通道 让我们创建 Hyperledger Fabric 区块链中的关键部分——通道。通道是主要的通信机制，联盟的成员可以通过该机制相互通信。网络中可以有多个通道，但现在我们将从一个开始。\n让我们看看第一个通道是如何被加入网络的：\n使用联盟定义 X1 为 R1 和 R2 创建了通道 C1。通道由完全独立于网络配置的通道配置 CC1 控制，CC1 由对 C1 拥有同等权利的 R1 和 R2 管理。R4 在 CC1 中没有任何权利。\n通道 C1 为联盟 X1 提供了专用的通信机制。我们可以看到通道 C1 已连接到排序服务 O4 ，但是没有附加任何内容。在网络开发的下一阶段，我们将连接组件，例如客户端应用程序和 peer 节点。但是在这一点上，通道代表着未来连接的潜力。\n即使通道 C1 是网络 N 的一部分，也可以从中分区出来。还要注意，组织 R3 和 R4 不在这个通道里——它只为 R1 和 R2 之间的交易处理。在上一步中，我们看到 R4 如何授权 R1 创建新联盟的权限。值得一提的是 R4 还允许 R1 创建通道！在这张图中，可能是组织 R1 或 R4 创建了通道 C1。同样，请注意，一个通道可以拥有任意数量的组织——我们刚刚展示了两个，因为它是最简单的配置。\n再次注意，通道 C1 有相较于网络配置 NC4 完全独立的配置 CC1。CC1 包含通道 C1 上 R1 和 R2 管理权限的策略（正如我们看到的），R3 和 R4 在这个通道上没有权限。如果 R3 和 R4 被 R1 或 R2 添加到通道配置 CC1 中的适当策略，则 R3 和 R4 只能与 C1 交互。这是一个定义谁可以把一个新组织加入到通道中的示例。特别注意，R4 不能把自己加入到通道 C1 中——它只能由 R1 或 R2 授权。\n为什么通道如此重要？通道有用是因为它们为联盟成员间的私有通讯和私有数据提供了一种机制。通道提供网络和其它通道的隐私性。Hyperledger Fabric 在这方面非常强大，因为它允许组织共享基础设施并同时保持其私有状态。这里没有矛盾——网络中不同的联盟将需要适当共享不同的信息和处理过程，通道提供一种有效的机制来做到这一点。通道可有效共享基础架构，同时保持数据和通信的隐私。\n我们还可以看到，一旦创建了一个通道，它实际上就是“脱离网络”。从此时到未来，只有在通道配置中明确指定的组织才能对其进行控制。同样，从此时开始对网络配置 NC4 的任何更新都不会直接影响通道配置 CC1；例如，如果联盟定义 X1 更新，它将不会影响通道 C1 的成员。通道之所以有用，是因为它们允许构成通道的组织之间进行隐私通信。此外，通道中的数据与网络的其余部分（包括其他通道）完全隔离。\n顺便说一句，还有一个特殊的系统通道，供排序服务使用。它的行为与常规通道完全相同，因此有时会称为应用程序通道。 我们通常不需要担心这个通道，但我们将在本篇文章的稍后部分对此讨论更多。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html#adding-network-administrators\n","id":10,"section":"posts","summary":"添加网络管理员 最初，NC4 被配置为仅允许 R4 的用户拥有网络管理权限。下一阶段，我们将允许组织 R1 的用户管理网络。让我们看看网络如何演进： 组织 R4 更","tags":["Hyperledger","Fabric","翻译"],"title":"Hyperledger Fabric 1.4 官方文档翻译之二：Key Concepts - Blockchain network (2)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%BA%8Ckey-concepts-blockchain-network-2/","year":"2019"},{"content":" 上一篇介绍了 Hugo 的安装，以及如何在 GitHub Page 上进行部署。这一篇将介绍如何在独立的服务器上部署站点。\n在服务器上部署站点，可以最大程度地自由发挥。首先，需要一台服务器，博客不需要太高的配置，入门级云服务器即可。然后，需要一个域名，这是您江湖上行走的ID，自己喜欢就好，不推荐暂时不能备案的（如 .org、.name 等）。此外，还需要 DNS 解析服务，有的域名商会在卖域名时附赠这项服务。总结一下，需要：\n 云服务器 域名 DNS 服务  Hugo 生成的是静态站点，推荐使用 nginx 作为博客的 web 服务器。\n下面，就开始部署吧。\n查看系统信息 $ cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) $ uname -r 3.10.0-862.el7.x86_64  安装 nginx 安装依赖 gcc-c++ 是 nginx 源码编译需要的 gcc 环境。\npcre、pcre-devel、zlib、zlib-devel、openssl、openssl-devel 是 nginx 源码编译依赖的库。\nyum -y install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel  创建 nginx 用户 给 nginx 服务分配单独的用户进行操作，以隔离风险。\nuseradd nginx su nginx  安装 nginx 下载最新版本的 nginx 源码。配置 configure 参数，把 nginx 安装在 nginx 的用户目录 opt/ 下，并设置 worker 进程 的默认用户为 nginx 。\nmkdir $HOME/download $HOME/opt cd ~/download wget https://nginx.org/download/nginx-1.16.1.tar.gz tar zxf nginx-1.16.1.tar.gz cd nginx-1.16.1 ./configure --prefix=/home/nginx/opt/nginx --user=nginx make \u0026amp; make install  配置环境变量 为 nginx 设置用户的环境变量。首先，在用户根目录下创建 bin/ 目录，用于存放所有应用程序的软链接。再将 bin/ 目录加入 PATH，并立即生效。最后，在 bin/ 目录下创建 nginx 的软链接。\nmkdir $HOME/bin echo -e '\\nPATH=/home/nginx/bin:$PATH\\n' \u0026gt;\u0026gt; /home/nginx/.bash_profile source /home/nginx/.bash_profile ln -s /home/nginx/opt/nginx/sbin/nginx /home/nginx/bin  启动 nginx 非超级用户不能监听1024以下的端口。所以，需要让 nginx 监听 8080 端口，再让 firewall 将 80 端口 的流量转发至 8080 端口。\n编辑 nginx 配置文件 ... server { listen 8080; # 把80改为8080 ... } ...  设置端口转发 # 使用 root 用户操作，需要 root 权限 su root systemctl start firewalld.service firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 --permanent firewall-cmd --reload  启动 nginx su nginx nginx  此时，浏览器打开，就能够看到 nginx 的欢迎页了。\n上传静态站点 将由 Hugo 生成的站点上传至服务器，推荐在 nginx 用户的根目录下，这样比较方便。关于如何使用 Hugo 生成静态站点，请查看上一篇。\n配置站点 再次编辑 nginx 的配置文件，设置站点域名、路由等。\nserver { listen 8080; server_name domain_name; # 博客域名 location / { root /path/to/site; # 博客站点的目录，注意要使用绝对路径 index index.html; } ... }  重新启动 nginx：\n$ nginx -s reload  此时，浏览器打开 服务器的 IP 地址，就能够看到您的博客首页了。\nDNS 解析 在 DNS 解析服务上，将 域名 指向 服务器的 IP 地址。浏览器打开 域名，就可以看到博客页面了。\n网站备案 注意，需要尽快进行网站备案，否则，很快就看不到您的网站了。\n软件版本 本文涉及到的软件版本如下：\n CentOS Linux release 7.5.1804 (Core) nginx 1.16.1 Hugo 0.60.1  参考 https://www.cnblogs.com/remyyoung/p/11244840.html\nhttps://www.cnblogs.com/boonya/p/7907999.html\n","id":11,"section":"posts","summary":"上一篇介绍了 Hugo 的安装，以及如何在 GitHub Page 上进行部署。这一篇将介绍如何在独立的服务器上部署站点。 在服务器上部署站点，可以最大程度地自由发挥。首先，","tags":["hugo","nginx"],"title":"Hugo 博客搭建之二：部署在服务器上","uri":"https://devjue.github.io/2019/12/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E4%BA%8C%E9%83%A8%E7%BD%B2%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/","year":"2019"},{"content":" 安装 Hugo mac 推荐使用 brew 进行安装：\n$ brew install hugo  windows 推荐从 GitHub 直接下载最新的稳定的二进制版本。然后，将其加入环境变量。\n源码安装 如果网络条件良好，也可以使用源码进行安装。因为 Hugo 是由 Go 语言编写的，所以需要 Go 语言环境。自从 Hugo 0.48 以后，Hugo 需要 Go 1.11 以上版本。把 Hugo 克隆在 GOPATH 的 src/ 目录下，并使用 Go 编译安装：\n$ mkdir $GOPATH/src $ cd $GOPATH/src $ git clone git@github.com:gohugoio/hugo.git $ cd hugo $ go install  生成的 hugo 可执行文件在 GOPATH/bin/ 目录下。\n生成站点 使用 hugo new site 命令生成新的站点，/path/to/site/ 是新站点的目录。\n$ hugo new site /path/to/site  创建文章 创建第一篇文章：\n$ cd /path/to/site $ hugo new post/hello_world.md  hello_world.md 会出现在 /path/to/site/content/post/ 目录下。\n安装皮肤 Hugo官网 有很多主题可供选择。选择您最喜欢的一款，下载到本地 theme 目录下。推荐使用 git clone 克隆项目，方便以后更新主题。但如果考虑到以后需要使用 GitHub 对博客版本进行管理，更推荐使用 git submodule add 将主题项目作为子模块添加。这部分不是本文讨论的重点，如果感兴趣，可以阅读《Hugo博客搭建之三：使用 GitHub 对博客版本进行管理》了解更多。本文还是介绍使用 git clone 克隆项目的方法。例如，我选择的是 pure :\n$ git clone git@github.com:xiaoheiAh/hugo-theme-pure.git themes/pure  运行 Hugo 使用 hugo server 启动 Hugo。\n$ hugo server -t pure -D   -t（--theme）指定主题名称，pure 是我们刚下载的主题的名字，如果您下载的是其它主题，则使用 theme 目录下该主题的名字。 -D（--buildDrafts）指生成包括被标记为 draft 的文章。文章在由 hugo new 命令生成后，没有进行任何编辑前，都被标记为 draft。如下所示，在新文章的头部：\n--- ... draft: true ---   刚才我们生成的第一篇文章 hello_world.md 也是被标记为 draft 的文章，如果启动 Hugo 时没有参数 -D，浏览器将不会显示任何文章。\n浏览器打开：http://localhost:1313。\n部署 Hugo 由于 Hugo 生成的是静态网站，所以可以部署在 GitHub Page 上。当然，它也可以部署在独立的服务器上。\n在 GitHub Page 上部署的好处是免费、操作简单，但访问速度有时候可能比较慢。可以使用默认域名，形如 yourname.github.io，也可以使用自己的域名。注意，下文出现的所有 yourname 都与此处一致。\n在独立的服务器上部署会比前者麻烦，并且需要一点服务器操作经验，但其容量、访问速度等限制都取决于服务器本身。此外，只能使用自己的域名。\n本篇文章将介绍在 GitHub Page 上部署站点，下一篇将介绍在独立的服务器上部署站点。\n创建 GitHub 仓库 首先，在 GitHub 上创建形如 yourname.github.io 的仓库。如下图所示（在此使用 devjue 作为 yourname ）：\n生成静态页面 在本地 /path/to/site/ 目录下，执行 hugo 命令：\n$ cd /path/to/site $ hugo -t pure -b \u0026quot;https://yourname.github.io/\u0026quot;   -b（--baseUrl）指定站点域名。   注意，以上命令不会生成被标记为 draft 的文章。\n 此时，Hugo 已经将所有的静态页面创建在 public/ 目录下。\n初始化仓库 在本地 /path/to/site/public/ 目录下，初始化仓库：\n$ cd /path/to/site/public $ git init $ git remote add origin git@github.com:yourname/yourname.github.io.git $ git add README.md $ git commit -m \u0026quot;init blog\u0026quot; $ git push -u origin master  如果一切顺利，浏览器打开 https://yourname.github.io/ ，就会看到您的站点了。\n软件版本 本文涉及到的软件版本如下：\n macOS Catalina 10.15.1 Windows 10 专业版 Hugo 0.60.1 hugo-theme-pure master at 2019/12/05  参考 https://www.gohugo.org/\nhttps://gohugo.io/getting-started/quick-start/\nhttps://pages.github.com/\n","id":12,"section":"posts","summary":"安装 Hugo mac 推荐使用 brew 进行安装： $ brew install hugo windows 推荐从 GitHub 直接下载最新的稳定的二进制版本。然后，将其加入环境变量。 源码安装 如果网络条件良好，也可以使用源","tags":["hugo"],"title":"Hugo 博客搭建之一：部署在 GitHub Page 上","uri":"https://devjue.github.io/2019/12/hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E4%B8%80%E9%83%A8%E7%BD%B2%E5%9C%A8github-page%E4%B8%8A/","year":"2019"},{"content":" 区块链 这篇文章将在概念层面讲述 Hyperledger Fabric 如何允许组织在形成区块链网络方面进行协作。如果您是架构师、管理员或开发者，则可以利用本篇文章深入了解 Hyperledger Fabric 区块链网络中的主要结构和流程组件。本篇文章将使用一个可管理的工作示例来介绍区块链网络中的所有主要组件。当了解这个示例后，您可以在文档的其它地方阅读更多有关这些组件的详细信息，或者尝试建立一个示例网络。\n阅读这篇文章并了解策略的概念后，您将对为控制一个已部署的区块链网络，组织需要建立策略这样的决定有深入了解。您还将了解组织是如何使用已声明的策略进行网络演进的管理，这些策略是 Hyperledger Fabric 的重要功能。简言之，您将了解 Hyperledger Fabric 的主要技术组件及组织需要对其做出的决策。\n什么是区块链网络 区块链网络是一种技术基础设施，它为应用程序提供账本和智能合约（链码）服务。首先，智能合约用于生成交易，这些交易随后会被分发到网络中的每一个 peer（译者按：由于“peer”已成为专有名词，本文将直接使用“peer”，而不将其翻译为“对等节点”）节点，交易被永远不变地记录在 peer 节点的账本副本上。应用程序的用户可以是使用客户端应用程序的终端用户或区块链网络的管理员。\n大多数情况下，多个组织聚集在一起作为联盟形成网络，它们的权限由最初配置网络时联盟协商一致的一组策略决定。此外，网络策略可能会随着时间的推移而改变，这取决于联盟内部组织的一致同意，当讨论 修改策略 时，我们会发现这一点。\n示例网络 在开始前，向您展示我们的目标。这是表示我们示例网络最终状态的图。\n不必担心，这可能看起来很复杂！在阅读本篇文章的过程中，我们将一点一点地把网络建立起来，以便您了解组织 R1、R2、R3 和 R4 如何为网络贡献基础设施以帮助形成网络。该基础设施实现了区块链网络，并且被网络中的组织（例如，可以添加新组织的组织）一致同意的策略所管理。您将发现应用程序如何使用由区块链网络提供的账本和智能合约服务。\n 组织（Organization）：R1、R2、R3、R4\n R1、R2、R3 和 R4 这四个组织共同决定并签署协议，它们将建立并利用 Hyperledger Fabric 网络。\n R4 被指定为网络的初始化者——它被授予创建网络最初版本的权力。R4 无意在网络中执行业务交易。\n R1 和 R2 以及 R2 和 R3 都需要在整个网络内进行隐私通信。\n R1 有一个客户端应用，通过通道 C1 执行业务交易。R2 也有一个客户端应用，通过 C1 和 C2 进行类似的工作。R3 有一个客户端应用，通过 C2 做相同的工作。\n  Peer 节点：P1、P2、P3\n P1 维护一个与 C1 连接的账本副本 L1。 P2 维护一个与 C1 连接的账本副本 L1 和与 C2 连接的账本副本 L2。P3 维护一个与 C2 连接的账本副本 L2。  通道（Channel）：C1、C2\n 账本（Ledger）：L1、L2\n 网络配置（Network Configuration）：NC4\n 本网络依赖网络配置 NC4 中指定的策略规则进行管理。本网络受 R1 和 R4 管理。  通道配置（Channel Configuration）：CC4\n C1 依赖通道配置 CC1 中指定的策略规则进行管理。C1 受 R1 和 R2 管理。\n C2 依赖通道配置 CC2 中指定的策略规则进行管理。C2 受 R2 和 R3 管理。\n  排序服务（Ordering Service）：O4\n 有一个排序服务O4，作为N的网络管理节点，并使用系统通道。\n 排序服务还支持应用程序通道 C1 和 C2，使交易排序打包进块里，为分发做准备。四个组织中每一个都有一个首选的证书颁发机构（Certificate Authority）。\n  颁发机构（Certificate Authority）：CA1、CA2、CA3、CA4\n  创建网络 让我们从创建网络的基础开始 ：\n启动排序者后便形成了网络。在我们的示例网络N中，由单个节点 O4 组成的排序服务根据网络配置 NC4 配置，NC4 授予 R4 管理权限。在网络层面，CA4 用于将身份分配给 R4 的管理员和网络节点。\n我们可以看到，排序服务 O4 首先定义了网络 N。将排序服务作为网络的最初管理节点很有用。按照事先约定，O4 最初由组织 R4 中的管理员配置和启动，并托管于 R4 中。配置 NC4 包含描述网络管理能力的最初集合的策略。最初，它设置只通过网络给 R4 权限。这将改变，正如我们后面将看到的，但是现在 R4 是网络的唯一成员。\n证书颁发机构（CA） 您还可以看到证书颁发机构 CA4，它用于向管理员和网络节点颁发证书。由于 CA4 分发 X.509 证书，所以它在我们的网络中有很重要的作用，该证书可以用来标示组件属于组织 R4。通过 CA 颁发的证书还可以用来签名交易，以表明组织认可交易结果——这是在账本上接受交易的先决条件。让我们更详细地研究 CA 的这两方面。\n首先，区块链网络的不同组件使用证书将自己标识为来自特定的组织。不同的组织通常使用不同的 CA。 Hyperledger Fabric 为您提供了一个内置的 CA（称为 Fabric-CA ）。但在实践中，组织将选择使用自己的 CA。\n证书到成员组织的映射是通过称为 Membership Services Provider (MSP) 的结构实现的。\n其次，稍后我们将看到CA颁发的证书如何成为交易生成和验证过程的核心。具体而言，X.509 证书用于客户端应用程序交易预案和智能合约交易响应中以进行数字签名交易。随后，托管账本副本的网络节点在接受交易到账本之前会验证交易签名是否有效。\n让我们回顾一下示例区块链网络的基本结构。网络 N 中的资源由证书颁发机构 CA4 定义的一组用户访问，这些用户对网络 N 中的资源具有一组权限，如网络配置 NC4 中包含的策略所述。当我们配置并启动订购服务节点 O4 时，所有这些都变为现实。\n参考 https://hyperledger-fabric.readthedocs.io/en/release-1.4/network/network.html\n","id":13,"section":"posts","summary":"区块链 这篇文章将在概念层面讲述 Hyperledger Fabric 如何允许组织在形成区块链网络方面进行协作。如果您是架构师、管理员或开发者，则可以利用本篇文章深入了解 Hyperledger Fabric 区","tags":["Hyperledger","Fabric","翻译"],"title":"Hyperledger Fabric 1.4 官方文档翻译之一：Key Concepts - Blockchain network (1)","uri":"https://devjue.github.io/2019/12/hyperledger-fabric-1.4-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E4%B9%8B%E4%B8%80key-concepts-blockchain-network-1/","year":"2019"}],"tags":[{"title":"byfn.sh","uri":"https://devjue.github.io/tags/byfn.sh/"},{"title":"Fabric","uri":"https://devjue.github.io/tags/fabric/"},{"title":"git","uri":"https://devjue.github.io/tags/git/"},{"title":"hugo","uri":"https://devjue.github.io/tags/hugo/"},{"title":"Hyperledger","uri":"https://devjue.github.io/tags/hyperledger/"},{"title":"nginx","uri":"https://devjue.github.io/tags/nginx/"},{"title":"翻译","uri":"https://devjue.github.io/tags/%E7%BF%BB%E8%AF%91/"}]}